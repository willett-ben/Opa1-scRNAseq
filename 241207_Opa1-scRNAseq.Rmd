---
title: "BW2310 Opa1 scRNAseq d5"
author: "Ben Willett"
date: "11/09/23"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
---


##    Notes:
- Regress out cell cycle at the beggining
- Cluster and remove contaminates
- Split naive and activated CD8s. Label in metadata
- Recombine objects so I can show violin plots for naive and activated cells
- I needed to redo the FindVariableFeatures(), scaling, etc. after I added the 'naive' and 'activated' labels to my cells
  
#     Install/Load packages (STEP 0)
This section is always required.  You will load all packages necessary for the scope of the assignment in between the code blocks.  

```{r, include =TRUE, echo=TRUE, message = FALSE}
# load packages here
library(SingleCellExperiment) #done
library(Seurat) #done
library(tidyverse) #done
library(Matrix) #done
library(scales) #done
library(cowplot) #done
library(RCurl) #done
library(AnnotationHub) #done
library(AnnotationFilter) #done
library(AnnotationDbi) #done
library(ensembldb) #done
library(SeuratWrappers) #done
library(harmony) #done
library(ggpubr) #done
library(gridExtra) #done
library(metap) #done
library(VISION) #done
library(clusterProfiler) #done
library(ggsci) #done
#library(lisi) #no but I don't think I need it
library(MetBrewer) #done
library(wesanderson) #done
library(scDblFinder) #done

#for later pathway analysis (taken from SBT's code)
library(readxl)
library(org.Mm.eg.db)
library(patchwork)
library(writexl)
library(fgsea)

#cNMF
library(readr)

```

<br/>

#     Read in Data 

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO

opa1 <- Read10X(data.dir = "~/Documents/Sandbox/Opa1-scRNAseq/10X_data/Opa1/10X_files", unique.features = TRUE, strip.suffix = TRUE)

wt <- Read10X(data.dir = "~/Documents/Sandbox/Opa1-scRNAseq/10X_data/WT/10X_files", unique.features = TRUE, strip.suffix = TRUE)


```

#     Generate Seurat Objects
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO

wt_obj <- CreateSeuratObject(counts = wt, project = "wt")
opa1_obj <- CreateSeuratObject(counts = opa1, project = "opa1")


```

<br/>  

#     Check metadata  
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

head(wt_obj@meta.data)
tail(wt_obj@meta.data)

head(opa1_obj@meta.data)
tail(opa1_obj@meta.data)

dim(wt_obj@meta.data) #7500 cells in WT sample
dim(opa1_obj@meta.data) #6700 cells in Opa1 sample

#check that row names are gene names
head(row.names(wt_obj@assays$RNA))
head(row.names(opa1_obj@assays$RNA))


#check that col names are barcodes (cells)
head(colnames(wt_obj@assays$RNA))
head(colnames(opa1_obj@assays$RNA))

```

Total reads across all cells in each sample

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

sum(wt_obj@meta.data$nCount_RNA)
sum(opa1_obj@meta.data$nCount_RNA)


```

#     Add sample specific metadata
##    Add genotype id 
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

wt_obj <- AddMetaData(wt_obj, metadata = "wt", col.name = "genotype")
opa1_obj <- AddMetaData(opa1_obj, metadata = "opa1", col.name = "genotype")

head(wt_obj@meta.data)
head(opa1_obj@meta.data)

```

#     Merge Data
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

merged_data_object <- merge(x = wt_obj,
                            y = opa1_obj,
                            add.cell.id = c("wt", "opa1"))

merged_data_object <- JoinLayers(merged_data_object)

```

##    Check merge success  

```{r include = TRUE, echo = TRUE}

head(merged_data_object@meta.data)
tail(merged_data_object@meta.data)
table(merged_data_object@meta.data$orig.ident)

```

#     Managing memory and space - post merge
```{r include=TRUE, echo=TRUE}

rm(wt, wt_obj, opa1, opa1_obj)
gc()

```

#     Data Setup and Formatting 
## Calculating per cell complexity and adding this to the metadata  
```{r include = TRUE, echo = TRUE}

merged_data_object <- AddMetaData(object = merged_data_object,
                                  metadata = log10(merged_data_object$nFeature_RNA)/log10(merged_data_object$nCount_RNA),col.name = "complexity")

head(merged_data_object$complexity)
tail(merged_data_object$complexity)
```

## Calculating mitochondrial read percentage per cell and adding this to the metadata  
```{r include = TRUE, echo = TRUE}

grep(rownames(merged_data_object@assays$RNA), pattern = "mt-", value = TRUE)
#Looks like "mt-" is the identifier for mitochondrial genes in this set

#Adding mitoPct to the metadata 
merged_data_object$mitoPct <- PercentageFeatureSet(object = merged_data_object, pattern = "mt-")

head(merged_data_object$mitoPct)
tail(merged_data_object$mitoPct)

```

#     Initial Data Exploration 
##    Total Cells per Sample  
```{r include = TRUE, echo = TRUE}

ggplot(merged_data_object@meta.data, aes(x=orig.ident, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle("Number of Cells Per Sample (raw)")

```

##    Distribution of total number of reads per cell  
```{r include = TRUE, echo = TRUE}

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic() +
ylab("Cell density") +
ggtitle("Distribution of reads per cell across samples")

```

##    Distribution of total number of unique genes expressed per cell  
```{r include = TRUE, echo = TRUE}

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) +
 geom_density(alpha = 0.2) +
 theme_classic() +
 scale_x_log10() +
ggtitle("Distribution of total unique genes per cell across samples")

ggplot(merged_data_object@meta.data, aes(x=orig.ident, y=log10(nFeature_RNA), fill=orig.ident)) +
geom_boxplot() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle("Distribution of unique genes expressed per cell (raw)")

```

##    Joint plot of reads, genes, and mitochondrial percentage  
```{r include = TRUE, echo = FALSE, message = FALSE, warning=FALSE}

ggplot(merged_data_object@meta.data, aes(x=nCount_RNA, y=nFeature_RNA, color=mitoPct)) +
   geom_point() +
   scale_colour_gradient(low = "gray90", high = "black") +
   stat_smooth(method=lm) + #throws in linear model line (blue line)
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(~orig.ident)

```

##    Distribution of mitochondrial percent per cell  
```{r include=TRUE, echo=TRUE, warning = FALSE}

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=mitoPct, fill=orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic()+
ggtitle("Distribution of mitochondrial contamination per cell across samples")

#Expected that the Opa1ko have even less mito chontamination than normal because the MITOCHONDRIAL GENOME IS NOT MAINTAINED in Opa1ko cells!!
```

##    Distribution of library complexity per cell
```{r include=TRUE, echo=TRUE}

ggplot(merged_data_object@meta.data, aes(x=complexity, color = orig.ident, fill=orig.ident)) +
        geom_density(alpha = 0.2) +
        theme_classic() + 
  ggtitle("Distribution of complexity across samples")

```

##    Other plots  
```{r include=TRUE, echo=TRUE}

VlnPlot(merged_data_object, features = c("nFeature_RNA", "nCount_RNA", "mitoPct"), ncol = 3)
VlnPlot(merged_data_object, features = c("nFeature_RNA", "nCount_RNA", "mitoPct"), stack = T)

```

#     Filtering 
##    Cell-Level filtering

* keep cells with at least 2000 unique genes present per cell  
* keep cells with at 8500 reads present per cell  
* keep cells that have a mitochondrial contamination percent of less than 10%  
* keep cell with a complexity of greater than 75%  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- subset(x = merged_data_object,
                               subset = 
                                 (nFeature_RNA >= 2000) &
                                 (nCount_RNA >= 8500) &
                                 (mitoPct < 10) &
                                 (complexity > 0.75))
```

* The total number of cells before filtering  
* The total number of cell after filtering  

```{r include = TRUE, echo = TRUE}

#this pulls the counts from the RNA object in the Seurat object
paste("The number of cells prior to filtering:")
dim(merged_data_object@meta.data)[1]

paste("The number of cells after filtering:")
dim(filtered_data_object@meta.data)[1]

```

##    Gene-Level filtering  

Remove the following genes:
* that have 0 counts across all cells  
* not present in at least 10 cells  

```{r include = TRUE, echo = TRUE}

#count variable:
#row names = gene
#col names = cells

counts <- LayerData(filtered_data_object, assay = "RNA", layer = "counts")

nonzero <- counts > 0
nonzero

#filter out everything with less than 10 reads across all cells
less_10 <- Matrix::rowSums(nonzero) >= 10
less_10_matrix <- counts[less_10,]
dim(less_10_matrix)
head(less_10_matrix)

#Using 10 as cutoff
keep_genes <- Matrix::rowSums(nonzero) >= 10
filtered_counts <- counts[keep_genes, ]
head(filtered_counts)
#rows = genes
#cols = barcodes

#32285 genes prior to filtering
dim(filtered_data_object@assays$RNA@features)

#13752 genes have been removed via this filtering
#less_10_matrix is the genes that remain after filtering. so ~18k genes remain after filtering
print(dim(filtered_data_object@assays$RNA@features)[1] - dim(less_10_matrix)[1])

filtered_data_object <- CreateSeuratObject(counts = filtered_counts, meta.data = filtered_data_object@meta.data)
```

#     Post-Filtering Data Exploration  
##    Total Cells per Sample  

```{r include = TRUE, echo = TRUE}

ggplot(filtered_data_object@meta.data, aes(x=orig.ident, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

```

##    Distribution of total number of reads per cell  

```{r include = TRUE, echo = TRUE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density") +
  geom_vline(xintercept = 1000, linetype = "dashed", color = "orange", linewidth = 2)

```

##    Distribution of total number of unique genes expressed per cell  

```{r include = TRUE, echo = TRUE, warning=FALSE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density")

```

##    Joint plot of reads, genes, and mitochondrial percentage  

```{r include = TRUE, echo = TRUE, warning=FALSE, message=FALSE}

ggplot(filtered_data_object@meta.data, aes(x=nCount_RNA, y=nFeature_RNA, color=mitoPct)) +
   geom_point() +
   scale_colour_gradient(low = "gray90", high = "black") +
   stat_smooth(method=lm) + #throws in linear model line (blue line)
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(~orig.ident)

```

##    Distribution of mitochondrial percent per cell  

```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=mitoPct, fill=orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic() +
geom_vline(xintercept = 20, linetype = "dashed", color = "orange", linewidth = 2)

```

##    Distribution of library complexity per cell  

```{r include=TRUE, echo=TRUE}

ggplot(filtered_data_object@meta.data, aes(x=complexity, color=orig.ident, fill=orig.ident)) +
        geom_density(alpha = 0.2) +
theme_classic()

```

##    Other plots  

```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}

VlnPlot(filtered_data_object, features = c("nCount_RNA", "nFeature_RNA", "mitoPct"), ncol = 3)
VlnPlot(filtered_data_object, features = c("nCount_RNA", "nFeature_RNA", "mitoPct"), stack = T)

```

##    Managing memory and space  .   

```{r include=TRUE, echo=TRUE}

#going to keep the merged_data_object in case I need to go back and refilter things
rm(nonzero, keep_genes, counts, filtered_counts, less_10_matrix, less_10)
gc()

```

#     Normalization and gene score calculations   
Now that we have visually identified some cell-level thresholds  

## Gene expression normalization  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- NormalizeData(object = filtered_data_object,
                                      normalization.method = "LogNormalize",
                                      assay = "RNA")

#sanity check for normalization. All of these are floats/continuous values. The raw data is integers
filtered_data_object@assays$RNA@layers

#merged data object has integers. So we're good
merged_data_object@assays$RNA@layers

```

## Calculate cell cycling scores    

```{r include = TRUE, echo = TRUE}

#this provides a list of agreed upon list of genes for cycling cells
cc.genes.updated.2019

filtered_data_object <- CellCycleScoring(object = filtered_data_object,
                                         g2m.features = cc.genes.updated.2019$g2m.genes,
                                         s.features = cc.genes.updated.2019$s.genes)

#check the meta.data for the new columns: S phase score, G2M score, cell cycle phase
head(filtered_data_object@meta.data)

```

Generate a bar graph where the x-axis is Phase to illustrate distribution of cells per phase.    

```{r include = TRUE, echo = TRUE}

#X is phase
ggplot(filtered_data_object@meta.data, aes(x=Phase, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

#X is genotype
ggplot(filtered_data_object@meta.data, aes(x=orig.ident, fill=Phase)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))
```  

#     PCA 

##    Identify most variable genes  
Use 2000 most variable genes:
Double check the list of genes that are generated: we do want to use these for PCA analysis, right?

```{r include = TRUE, echo=TRUE}

#2000 genes is a good starting point, no real need to use 5k or more
#FindVariableFeatures knows to use the normalized data. Back end Seurat stuff going on here, don't really need to worry about that
filtered_data_object <- FindVariableFeatures(object = filtered_data_object,
                                             selection.method = "vst",
                                             nfeatures = 2000,
                                             verbose = FALSE,
                                             assay = "RNA")

VariableFeatures(object = filtered_data_object,
                 selection.method = "vst",
                 assay = "RNA")

variableGeneDf <- as_tibble(HVFInfo(filtered_data_object,
                                    selection.method = "vst",
                                    status = TRUE,
                                    assay = "RNA"),
                                    rownames = "Gene")

variableGeneDf = variableGeneDf %>%
  mutate(hypervariable=Gene %in%
           VariableFeatures(filtered_data_object,
                            selection.method = "vst",
                            assay = "RNA"))

ggplot(variableGeneDf, aes(x = log(mean),
                       y = log(variance),
                       color = hypervariable)) +
                       geom_point()

```

##    Scale the data 
  *Regress out cell cycle

```{r include = TRUE, echo = TRUE}

filtered_data_object <- ScaleData(object = filtered_data_object,
                                  assay = "RNA",
                                  vars.to.regress = "Phase")


```

##    Calculate principle components 

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunPCA(object = filtered_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)

```

##    Visualizing of principle components  
###   Dim Plots
* Phase  
* stimulation_status  
* orig.ident  

```{r include=TRUE, echo=TRUE}

DimPlot(filtered_data_object, reduction = "pca", group.by = "Phase", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", split.by = "Phase", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", group.by = "orig.ident", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", group.by = "Phase", split.by = "orig.ident", order = TRUE)

```

###   FeaturePlots

*  mitchondrial percentage

```{r include=TRUE, echo=TRUE}

FeaturePlot(object = filtered_data_object,
            reduction = "pca",
            features = "mitoPct",
            split.by = "orig.ident",
            order = TRUE)

DimHeatmap(object = filtered_data_object,
           dims = 1:9,
           cells = 500,
           balanced = TRUE,
           assays = "RNA",
           reduction = "pca"
           )

```

###   Elbow Plot  

    Decide how many PCs to use.
Using 20

```{r include = TRUE, echo = TRUE}

ElbowPlot(object = filtered_data_object, ndims = 50, reduction = "pca")
pcs = 20

```

###   *t*-SNE  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunTSNE(object = filtered_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "initial_tsne")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_tsne", group.by = "orig.ident")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_tsne", group.by = "Phase")

```

### UMAP  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunUMAP(object = filtered_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "initial_umap")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "orig.ident")
DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "Phase")
DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "Phase", split.by = "orig.ident")

```

#     Clustering 

## Find cell neighbors
  --> Uses pcs variable defined earlier

```{r include=TRUE, echo=TRUE}

filtered_data_object <- FindNeighbors(object = filtered_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

```

## Cluster cells based on neighborhood

```{r inclue = TRUE, echo = TRUE}

#for resolution, pick a few to start with and refine from there.
filtered_data_object <- FindClusters(object = filtered_data_object,
                                     resolution = c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.6, 1.0, 1.4),
                                     algorithm = 1,
                                     random.seed = 18)

#forgot how to set "seurat_clusters" variable to the resolution I'm using so this is for that
filtered_data_object <- FindClusters(object = filtered_data_object,
                                     resolution = 0.15,
                                     algorithm = 1,
                                     random.seed = 18)

```

## Select clustering resolution to test  
### Resolution picked: 0.15
```{r include = TRUE, echo = TRUE}

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15",
        split.by = "orig.ident") +
        ggtitle("Res = 0.15")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15",
        split.by = "Phase") +
        ggtitle("Res = 0.15")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15") +
        ggtitle("Res = 0.15")

```

### Other resolutions tested:
```{r include = TRUE, echo = TRUE}

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.1",
        split.by = "orig.ident") +
        ggtitle("Res = 0.1")



DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.2",
        split.by = "orig.ident") +
        ggtitle("Res = 0.2")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.2",
        split.by = "Phase") +
        ggtitle("Res = 0.2")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.25",
        split.by = "orig.ident") +
        ggtitle("Res = 0.25")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.3",
        split.by = "orig.ident") +
        ggtitle("Res = 0.3")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.4",
        split.by = "orig.ident") +
        ggtitle("Res = 0.4")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.1",
        split.by = "orig.ident") +
        ggtitle("Res = 1")


```


### Integrating?
Not proceeding with integration on this data.
Wanted to try it for the sake of practice but ran into issues installing lisi library
```{r include = TRUE, echo = TRUE}




```


#     Covariate check of clusters     

##Feature plots

* nCount_RNA  (reads)
* nFeature_RNA  (genes)
* mitoPct  (percent mito genes)

```{r include = TRUE, echo = TRUE}

FeaturePlot(object = filtered_data_object,
            reduction = "initial_umap",
            features = "nCount_RNA",
            split.by = "orig.ident",
            order = TRUE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = filtered_data_object,
            reduction = "initial_umap",
            features = "nFeature_RNA",
            split.by = "orig.ident",
            order = TRUE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = filtered_data_object,
            reduction = "initial_umap",
            features = "mitoPct",
            split.by = "orig.ident",
            order = TRUE) + theme(legend.position = c(0.8,0.9))
``` 

## IDing clusters based on commonly expressed genes

  cluster 5 = RBCs (Hba-a1 = hemoglobin)
  cluster 6,8 = CD163l1 -> some sort of fetal-derived CD8s
  cluster 7 = Macrophages/B cells (H2-Ab1 = MHC class II), Spi1 is a B cell/Myeloid dev marker, Ms4a1 is CD20
  Part of cluster 1 will probably be removed later after I reclusters T cells
  
  Based on above and CD8 and CD3e expression, clusters 0-4 are what I want

```{r include = TRUE, echo = TRUE}

VlnPlot(filtered_data_object, features = c("Cd19","Ms4a1","Hba-a1", "H2-Ab1","Ncr1","Cd3e","Cd8a","Spi1", "Cd4", "Cd24a", "Ikzf2", "Cd163l1","Igf1r","St6galnac3", "Itgal", "Itgam", "Fcgr3a"),group.by = "seurat_clusters", combine = FALSE)

``` 


## Identify doublets

```{r include = TRUE, echo = TRUE, eval = TRUE}

scDblObj <- scDblFinder(as.SingleCellExperiment(filtered_data_object), samples = "orig.ident")

filtered_data_object <- AddMetaData(filtered_data_object,
                                 metadata = as.data.frame(scDblObj@colData[,c("scDblFinder.class", "scDblFinder.score", "scDblFinder.weighted", "scDblFinder.cxds_score", "scDblFinder.sample")]))

table(filtered_data_object@meta.data$scDblFinder.class,
      filtered_data_object@meta.data$scDblFinder.sample)

#I have some doublets
DimPlot(object = filtered_data_object, reduction = "initial_umap",
       group.by = "scDblFinder.class", split.by = "orig.ident", order = TRUE)

Idents(filtered_data_object) <- "scDblFinder.class"

filtered_data_object <- subset(x = filtered_data_object, idents = "singlet")

#doublet have been removed - yes, this is the same code as above
table(filtered_data_object@meta.data$scDblFinder.class,
      filtered_data_object@meta.data$scDblFinder.sample)

DimPlot(object = filtered_data_object, reduction = "initial_umap",
       group.by = "scDblFinder.class", split.by = "orig.ident", order = TRUE)
```

#     Create new (2nd) Seurat Object for the T cell clusters only (clusters 0-4).
      Will recluster and see if there' anything else I need to get rid of.

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- filtered_data_object %>% subset(seurat_clusters %in% c("0","1","2","3","4"))

table(Tcell_data_object@meta.data$RNA_snn_res.0.15, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@meta.data$Phase, Tcell_data_object@meta.data$genotype)

#Ok. Non-Tcell clusters have been removed. 

```

##    ReRun t-SNE, UMAP, and clustering for Tcell only data

### t-SNE    
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunTSNE(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "Tcell_tsne")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "orig.ident")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "Phase")

```

### UMAP  
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunUMAP(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "Tcell_umap")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "orig.ident")

```


##    Re-Clustering
      Looking for 4 clusters here - they will wind up being naive, d5 G1, d5 dividing, and d5 Opa1-unique
      Have had to change the resolution between 0.05 and 0.1 before

###   Resolution using = 0.075 (241213)

```{r include = TRUE, echo = TRUE}
Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = 0.075,
                                     algorithm = 1,
                                     random.seed = 18)


DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.075",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.075")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.075",
        split.by = "Phase") +
        ggtitle("Resolution = 0.075")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "orig.ident",
        split.by = "Phase") +
        ggtitle("Resolution = 0.075")

# Get number of cells per cluster and per sample of origin
table(Tcell_data_object@meta.data$RNA_snn_res.0.1, Tcell_data_object@meta.data$orig.ident)

Idents(object = Tcell_data_object) <- "RNA_snn_res.0.075"
```

###   Other resolutions tested

```{r include = TRUE, echo = TRUE}

pcs <- 20

#clustering
Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = c(0.05, 0.1,0.15, 0.2,0.225, 0.25,0.275, 0.3, 0.4),
                                     algorithm = 1,
                                     random.seed = 18)

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.05",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.1")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.2",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.2")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.275") +
        ggtitle("Resolution = 0.275")



#NOTE: Moving forward, after some troubleshooting and analyses downstream of higher resolutions. Choosing resolution 0.1. To get 4 clusters. Two clusters are in G1 and two clusters are dividing.

```






#     T Cell cluster wrangling
          Resolution = 0.075 (This has been 0.1 before. Looking for 4 total clusters: naive and 3 activated. 2 G1                clusters, 2 dividing)
##   Identify Naive T cell cluster based on Lef1 and Tcf7 expression.
```{r include = TRUE, echo = TRUE}

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Lef1",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Tcf7",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

```

##    Label cells as Naive and activated. Made new seurat objects to do this (probably an easier way?). Recombined and replaced Tcell_data_object
      Can save Naive and activated groups of cells as RDS files, if wanted for some type of analysis that way.

```{r include = TRUE, echo = TRUE}
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")

#naive
Naive_data_object <- Tcell_data_object %>% subset(seurat_clusters %in% c("0"))
Naive_data_object <- AddMetaData(Naive_data_object, metadata = "naive", col.name = "activation_status")

#save/load if needed
#saveRDS(object = Naive_data_object, "~/Documents/Sandbox/Opa1-scRNAseq/Naive_object_phase_regress.RDS")
#Naive_data_object <- readRDS("~/Desktop/Opa1_scRNAseq/241207_naive_object_phase_regress.RDS")

#activated
Activated_data_object <- Tcell_data_object %>% subset(seurat_clusters %in% c("1", "2", "3"))
Activated_data_object <- AddMetaData(Activated_data_object, metadata = "activated", col.name = "activation_status")

#Save/load if needed
#saveRDS(object = Activated_data_object, "~/Documents/Sandbox/Opa1-scRNAseq/Activated_object_phase_regress.RDS")
#Activated_data_object <- readRDS("~/Documents/Sandbox/Opa1-scRNAseq/Activated_object_phase_regress.RDS"")


#Merge data back together
Tcell_data_object <- merge(x = Naive_data_object,
                           y = Activated_data_object)

Tcell_data_object <- JoinLayers(Tcell_data_object)

table(Tcell_data_object@meta.data$activation_status, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@active.ident, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@active.ident, Tcell_data_object@meta.data$activation_status)



```

I need to rerun PCA, tsne, and UMAP for Tcell object. And rescale the data. The first command in the last section (Dimplot) will NOT work right now because the PCA and reductions are not in Tcell object anymore
Yes, probably could've done this in a less computationally expensive way. Like adding metadata based on cluster... Doing this for now and will come back later and redo it if I have time

##     Redo PCAs for Tcell_data_object 
```{r include = TRUE, echo=TRUE}
# TO DO
#2000 genes is a good starting point, no real need to use 5k or more
#FindVariableFeatures knows to use the normalized data. Back end Seurat stuff going on here, don't really need to worry about that
Tcell_data_object <- FindVariableFeatures(object = Tcell_data_object,
                                             selection.method = "vst",
                                             nfeatures = 2000,
                                             verbose = FALSE,
                                             assay = "RNA")

head(VariableFeatures(object = Tcell_data_object,
                 selection.method = "vst",
                 assay = "RNA"))

variableGeneDf <- as_tibble(HVFInfo(Tcell_data_object,
                                    selection.method = "vst",
                                    status = TRUE,
                                    assay = "RNA"),
                                    rownames = "Gene")

variableGeneDf = variableGeneDf %>%
  mutate(hypervariable=Gene %in%
           VariableFeatures(Tcell_data_object,
                            selection.method = "vst",
                            assay = "RNA"))

ggplot(variableGeneDf, aes(x = log(mean),
                       y = log(variance),
                       color = hypervariable)) +
                       geom_point()

```


###    Scale the data 
          *Regress out cell cycle

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- ScaleData(object = Tcell_data_object,
                                  assay = "RNA",
                                  vars.to.regress = "Phase")

```

###    Calculate principle components 

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunPCA(object = Tcell_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)

```

###    Decide how many PCs to use.
          Using 20

```{r include = TRUE, echo = TRUE}

ElbowPlot(object = Tcell_data_object, ndims = 50, reduction = "pca")
pcs = 20

```

###    t-SNE    
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunTSNE(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "Tcell_tsne")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "orig.ident")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "Phase")

```

###    UMAP  
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunUMAP(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "Tcell_umap")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "orig.ident")

```


##    T cell UMAP if needed
```{r include = TRUE, echo = TRUE}

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.075",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.075")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        group.by = "Phase",
        split.by = "orig.ident", cols = c("gray", "orange", "#009E73")) + 
        theme(strip.text.x = element_text(size = 20, face = "bold") ) +
        ggtitle("") + xlab("Tcell UMAP 1") + ylab("Tcell UMAP 2")

```


##    Clean up metadata - remove unused columns
          Tried a few ways. This worked. Not efficient, I know.
          Clustering resolution is still 0.075
```{r include = TRUE, echo = TRUE}

Tcell_data_object

Tcell_data_object$RNA_snn_res.0.05 <- NULL
Tcell_data_object$RNA_snn_res.0.1 <- NULL
Tcell_data_object$RNA_snn_res.0.2 <- NULL
Tcell_data_object$RNA_snn_res.0.3 <- NULL
Tcell_data_object$RNA_snn_res.0.4 <- NULL
Tcell_data_object$RNA_snn_res.0.6 <- NULL
Tcell_data_object$RNA_snn_res.1 <- NULL
Tcell_data_object$RNA_snn_res.1.4 <- NULL
Tcell_data_object$RNA_snn_res.0.25 <- NULL
Tcell_data_object$RNA_snn_res.0.15 <- NULL
Tcell_data_object$RNA_snn_res.0.225 <- NULL
Tcell_data_object$RNA_snn_res.0.275 <- NULL
Tcell_data_object$RNA_snn_res.0.175 <- NULL
Tcell_data_object$RNA_snn_res.0.18 <- NULL
Tcell_data_object$RNA_snn_res.0.19 <- NULL
Tcell_data_object$scDblFinder.class <- NULL
Tcell_data_object$scDblFinder.weighted <- NULL
Tcell_data_object$scDblFinder.score <- NULL
Tcell_data_object$scDblFinder.sample <- NULL
Tcell_data_object$scDblFinder.cxds_score <- NULL

#good to check. Other metadata columns look good
Tcell_data_object

```















delete down below??? - have not renamed the clusters yet!


#    Removing the WT cells in the opa1_unique cluster (has popped up before. Not needed 241213)
```{r include = TRUE, echo = TRUE}

#found the wt cell in this clusters: "wt_TGTTACTTCACAATGC"
head(WhichCells(Tcell_data_object, ident = "d5_opa1_unique"), 10)
#toRemove <- "wt_TGTTACTTCACAATGC"

#wt cell has been removed
#Tcell_data_object <- Tcell_data_object[, !colnames(Tcell_data_object) %in% toRemove]
table(Tcell_data_object@meta.data$RNA_snn_res.0.075, Tcell_data_object@meta.data$orig.ident)

```








#    Managing memory and space

```{r include=TRUE, echo=TRUE}

#Removing merged and filtered data objects - we've gotten to a good spot with our clusters and groups
#Removing Activated and Naive data objects - those can be rederived, if wanted.
#Don't need the dublets ID data
rm(Activated_data_object, Naive_data_object, filtered_data_object, merged_data_object, scDblObj, cluster_names)
gc()


```






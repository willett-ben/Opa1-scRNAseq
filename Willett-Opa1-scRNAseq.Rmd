---
title: "BW2310 Opa1 scRNAseq d5"
author: "Ben Willett"
date: "11/09/23"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
---


##    Notes:
- Regress out cell cycle at the beggining
- Cluster and remove contaminates
- Split naive and activated CD8s. Label in metadata
- Recombine objects so I can show violin plots for naive and activated cells
- I needed to redo the FindVariableFeatures(), scaling, etc. after I added the 'naive' and 'activated' labels to my cells
  
#     Install/Load packages (STEP 0)
This section is always required.  You will load all packages necessary for the scope of the assignment in between the code blocks.  

```{r, include =TRUE, echo=TRUE, message = FALSE}
# load packages here
library(SingleCellExperiment) #done
library(Seurat) #done
library(tidyverse) #done
library(Matrix) #done
library(scales) #done
library(cowplot) #done
library(RCurl) #done
library(AnnotationHub) #done
library(AnnotationFilter) #done
library(AnnotationDbi) #done
library(ensembldb) #done
library(SeuratWrappers) #done
library(harmony) #done
library(ggpubr) #done
library(gridExtra) #done
library(metap) #done
library(VISION) #done
library(clusterProfiler) #done
library(ggsci) #done
#library(lisi) #no but I don't think I need it
library(MetBrewer) #done
library(wesanderson) #done
library(scDblFinder) #done

#for later pathway analysis (taken from SBT's code)
library(readxl)
library(org.Mm.eg.db)
library(patchwork)
library(writexl)
library(fgsea)

#cNMF
library(readr)

```

<br/>

#     Read in Data 

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO

opa1 <- Read10X(data.dir = "~/Desktop/Opa1_scRNAseq/Opa1/10X_files", unique.features = TRUE, strip.suffix = TRUE)

wt <- Read10X(data.dir = "~/Desktop/Opa1_scRNAseq/WT/10X_files", unique.features = TRUE, strip.suffix = TRUE)


```

#     Generate Seurat Objects
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO

wt_obj <- CreateSeuratObject(counts = wt, project = "wt")
opa1_obj <- CreateSeuratObject(counts = Opa1, project = "Opa1")


```

<br/>  

#     Check metadata  
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO
head(wt_obj@meta.data)
tail(wt_obj@meta.data)

head(opa1_obj@meta.data)
tail(opa1_obj@meta.data)

dim(wt_obj@meta.data) #7500 cells in WT sample
dim(opa1_obj@meta.data) #6700 cells in Opa1 sample

#check that row names are gene names
row.names(wt_obj@assays$RNA)
row.names(opa1_obj@assays$RNA) 
#yep

#check that col names are barcodes (cells)
colnames(wt_obj@assays$RNA) 
colnames(opa1_obj@assays$RNA)
#yep
```






How could we tell how many reads are being considered across all cells in each sample?  

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO

sum(wt_obj@meta.data$nCount_RNA)
sum(opa1_obj@meta.data$nCount_RNA)


```

#     Add sample specific metadata
##    Add genotype id 
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO
wt_obj <- AddMetaData(wt_obj, metadata = "wt", col.name = "genotype")
opa1_obj <- AddMetaData(opa1_obj, metadata = "opa1", col.name = "genotype")


```

Now let's check that our metadata looks good:  

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO
head(wt_obj@meta.data)
head(opa1_obj@meta.data)
#genotype data added
```

#     Merge Data
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
# TO DO

merged_data_object <- merge(x = wt_obj,
                            y = opa1_obj,
                            add.cell.id = c("wt", "opa1"))

merged_data_object <- JoinLayers(merged_data_object)

```


##    Check merge success  
It is critical that once the data has been merged, that you check the final merged data set to make sure it is what you expected.  
<br/>  

4.  Check that the object merged correctly by:  

* performing a `head` on the `meta.data`  
* performing a `tail` on the `meta.data`  
* generating a table summary of the `orig.ident` that shows how many cells come from each sample  

```{r include = TRUE, echo = TRUE}
#TO DO

head(merged_data_object@meta.data)
tail(merged_data_object@meta.data)
table(merged_data_object@meta.data$orig.ident)


```


#     Managing memory and space - post merge
```{r include=TRUE, echo=TRUE}
#TO DO
rm(wt, wt_obj, opa1, opa1_obj)
gc()
```

#     Data Setup and Formatting 
## Calculating per cell complexity and adding this to the metadata  
```{r include = TRUE, echo = TRUE}
# TO DO

merged_data_object <- AddMetaData(object = merged_data_object,
                                  metadata = log10(merged_data_object$nFeature_RNA)/log10(merged_data_object$nCount_RNA),col.name = "complexity")

head(merged_data_object$complexity)
tail(merged_data_object$complexity)
```

## Calculating mitochondrial read percentage per cell and adding this to the metadata  
```{r include = TRUE, echo = TRUE}
# TO DO

grep(rownames(merged_data_object@assays$RNA), pattern = "mt-", value = TRUE)
#Looks like "mt-" is the identifier for mitochondrial genes in this set

#Adding mitoPct to the metadata 
merged_data_object$mitoPct <- PercentageFeatureSet(object = merged_data_object, pattern = "mt-")

head(merged_data_object$mitoPct)
tail(merged_data_object$mitoPct)

```

<br/> 


#     Initial Data Exploration 
##    Total Cells per Sample  
```{r include = TRUE, echo = TRUE}
# TO DO

ggplot(merged_data_object@meta.data, aes(x=orig.ident, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle("Number of Cells Per Sample (raw)")


```

<br/>  

##    Distribution of total number of reads per cell  
```{r include = TRUE, echo = TRUE}
# TO DO

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic() +
ylab("Cell density") +
ggtitle("Distribution of reads per cell across samples")


```

<br/>  

##    Distribution of total number of unique genes expressed per cell  
```{r include = TRUE, echo = TRUE}
# TO DO

#similar code, just changing out the metadata column that we are graphing
ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) +
 geom_density(alpha = 0.2) +
 theme_classic() +
 scale_x_log10() +
ggtitle("Distribution of total unique genes per cell across samples")

# TO DO -- THE BOXPLOT VERSION

ggplot(merged_data_object@meta.data, aes(x=orig.ident, y=log10(nFeature_RNA), fill=orig.ident)) +
geom_boxplot() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle("Distribution of unique genes expressed per cell (raw)")


```

<br/>  

##    Joint plot of reads, genes, and mitochondrial percentage  
```{r include = TRUE, echo = FALSE, message = FALSE, warning=FALSE}
# TO DO 

#

ggplot(merged_data_object@meta.data, aes(x=nCount_RNA, y=nFeature_RNA, color=mitoPct)) +
   geom_point() +
   scale_colour_gradient(low = "gray90", high = "black") +
   stat_smooth(method=lm) + #throws in linear model line (blue line)
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(~orig.ident)

```

<br/>  

##    Distribution of mitochondrial percent per cell  
```{r include=TRUE, echo=TRUE, warning = FALSE}
# TO DO

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=mitoPct, fill=orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic()+
ggtitle("Distribution of mitochondrial contamination per cell across samples")

#Expected that the Opa1ko have even less mito chontamination than normal because the MITOCHONDRIAL GENOME IS NOT MAINTAINED in Opa1ko cells!!
```

<br/>  

##    Distribution of library complexity per cell
```{r include=TRUE, echo=TRUE}
# TO DO


ggplot(merged_data_object@meta.data, aes(x=complexity, color = orig.ident, fill=orig.ident)) +
        geom_density(alpha = 0.2) +
        theme_classic() + 
  ggtitle("Distribution of complexity across samples")

```

##    Other plots  
```{r include=TRUE, echo=TRUE}
# TO DO

VlnPlot(merged_data_object, features = c("nFeature_RNA", "nCount_RNA", "mitoPct"), ncol = 3)
VlnPlot(merged_data_object, features = c("nFeature_RNA", "nCount_RNA", "mitoPct"), stack = T)

```








#     Filtering 
##    Cell-Level filtering

* keep cells with at least 200 unique genes present per cell  
* keep cells with at 1000 reads present per cell  
* keep cells that have a mitochondrial contamination percent of less than 20%  
* keep cell with a complexity of greater than 80%  


```{r include = TRUE, echo = TRUE}
# TO DO  

filtered_data_object <- subset(x = merged_data_object,
                               subset = 
                                 (nFeature_RNA >= 2000) &
                                 (nCount_RNA >= 8500) &
                                 (mitoPct < 10) &
                                 (complexity > 0.75))
```

* The total number of cells before filtering  
* The total number of cell after filtering  

```{r include = TRUE, echo = TRUE}
# TO DO  

#this pulls the counts from the RNA object in the Seurat object
paste("The number of cells prior to filtering:")
dim(merged_data_object@meta.data)[1]

paste("The number of cells after filtering:")
dim(filtered_data_object@meta.data)[1]


```

##    Gene-Level filtering  

Remove the following genes:
* that have 0 counts across all cells  
* not present in at least 10 cells  

```{r include = TRUE, echo = TRUE}

#count variable:
#row names = gene
#col names = cells

counts <- LayerData(filtered_data_object, assay = "RNA", layer = "counts")

nonzero <- counts > 0
nonzero

#filter out everything with less than 10 reads across all cells
less_10 <- Matrix::rowSums(nonzero) >= 10
less_10_matrix <- counts[less_10,]
dim(less_10_matrix)
head(less_10_matrix)


#Using 10 as cutoff
keep_genes <- Matrix::rowSums(nonzero) >= 10
filtered_counts <- counts[keep_genes, ]
head(filtered_counts)
#rows = genes
#cols = barcodes

#32285 genes prior to filtering
dim(filtered_data_object@assays$RNA@features)

#13752 genes have been removed via this filtering
#less_10_matrix is the genes that remain after filtering. so ~18k genes remain after filtering
print(dim(filtered_data_object@assays$RNA@features)[1] - dim(less_10_matrix)[1])


filtered_data_object <- CreateSeuratObject(counts = filtered_counts, meta.data = filtered_data_object@meta.data)
```


#     Post-Filtering Data Exploration  
##    Total Cells per Sample  
```{r include = TRUE, echo = TRUE}

ggplot(filtered_data_object@meta.data, aes(x=orig.ident, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

```
<br/>  
##    Distribution of total number of reads per cell  

```{r include = TRUE, echo = TRUE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density") +
  geom_vline(xintercept = 1000, linetype = "dashed", color = "orange", linewidth = 2)

```
##    Distribution of total number of unique genes expressed per cell  

```{r include = TRUE, echo = TRUE, warning=FALSE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density")


```

<br/>  

##    Joint plot of reads, genes, and mitochondrial percentage  

```{r include = TRUE, echo = TRUE, warning=FALSE, message=FALSE}

ggplot(filtered_data_object@meta.data, aes(x=nCount_RNA, y=nFeature_RNA, color=mitoPct)) +
   geom_point() +
   scale_colour_gradient(low = "gray90", high = "black") +
   stat_smooth(method=lm) + #throws in linear model line (blue line)
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(~orig.ident)

```

##    Distribution of mitochondrial percent per cell  

```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=mitoPct, fill=orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic() +
geom_vline(xintercept = 20, linetype = "dashed", color = "orange", linewidth = 2)

```

##    Distribution of library complexity per cell  

```{r include=TRUE, echo=TRUE}

ggplot(filtered_data_object@meta.data, aes(x=complexity, color=orig.ident, fill=orig.ident)) +
        geom_density(alpha = 0.2) +
theme_classic()

```

<br/>  

##    Other plots  

```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}

VlnPlot(filtered_data_object, features = c("nCount_RNA", "nFeature_RNA", "mitoPct"), ncol = 3)
VlnPlot(filtered_data_object, features = c("nCount_RNA", "nFeature_RNA", "mitoPct"), stack = T)

```


##    Managing memory and space  .   

```{r include=TRUE, echo=TRUE}

#going to keep the merged_data_object in case I need to go back and refilter things
rm(nonzero, keep_genes, counts, filtered_counts, less_10_matrix, less_10)
gc()


```

<br/>  

#     Normalization and gene score calculations   
Now that we have visually identified some cell-level thresholds  

## Gene expression normalization  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- NormalizeData(object = filtered_data_object,
                                      normalization.method = "LogNormalize",
                                      assay = "RNA")

#sanity check for normalization. All of these are floats/continuous values. The raw data is integers
filtered_data_object@assays$RNA@layers

#merged data object has integers. So we're good
merged_data_object@assays$RNA@layers


```

## Calculate cell cycling scores    

```{r include = TRUE, echo = TRUE}

#this provides a list of agreed upon list of genes for cycling cells
cc.genes.updated.2019

filtered_data_object <- CellCycleScoring(object = filtered_data_object,
                                         g2m.features = cc.genes.updated.2019$g2m.genes,
                                         s.features = cc.genes.updated.2019$s.genes)

#check the meta.data for the new columns: S phase score, G2M score, cell cycle phase
head(filtered_data_object@meta.data)

```

Generate a bar graph where the x-axis is Phase to illustrate distribution of cells per phase.    

```{r include = TRUE, echo = TRUE}

#X is phase
ggplot(filtered_data_object@meta.data, aes(x=Phase, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

#X is genotype
ggplot(filtered_data_object@meta.data, aes(x=orig.ident, fill=Phase)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))
```  

#     PCA 

##    Identify most variable genes  
Use 2000 most variable genes:

```{r include = TRUE, echo=TRUE}

#2000 genes is a good starting point, no real need to use 5k or more
#FindVariableFeatures knows to use the normalized data. Back end Seurat stuff going on here, don't really need to worry about that
filtered_data_object <- FindVariableFeatures(object = filtered_data_object,
                                             selection.method = "vst",
                                             nfeatures = 2000,
                                             verbose = FALSE,
                                             assay = "RNA")

VariableFeatures(object = filtered_data_object,
                 selection.method = "vst",
                 assay = "RNA")

# TO DO : EXPLORE YOUR VARIABLE FEATURES -- ARE THESE THE GENES YOU WANT TO USE FOR CLUSTERING?

variableGeneDf <- as_tibble(HVFInfo(filtered_data_object,
                                    selection.method = "vst",
                                    status = TRUE,
                                    assay = "RNA"),
                                    rownames = "Gene")

variableGeneDf = variableGeneDf %>%
  mutate(hypervariable=Gene %in%
           VariableFeatures(filtered_data_object,
                            selection.method = "vst",
                            assay = "RNA"))

ggplot(variableGeneDf, aes(x = log(mean),
                       y = log(variance),
                       color = hypervariable)) +
                       geom_point()

```


##    Scale the data 
  *Regress out cell cycle

```{r include = TRUE, echo = TRUE}

filtered_data_object <- ScaleData(object = filtered_data_object,
                                  assay = "RNA",
                                  vars.to.regress = "Phase")


```

##    Calculate principle components 

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunPCA(object = filtered_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)


```

<br/>  

##    Visualizing of principle components  
###   Dim Plots
* Phase  
* stimulation_status  
* orig.ident  

```{r include=TRUE, echo=TRUE}

DimPlot(filtered_data_object, reduction = "pca", group.by = "Phase", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", split.by = "Phase", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", group.by = "orig.ident", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", group.by = "Phase", split.by = "orig.ident", order = TRUE)

```

###   FeaturePlots

*  mitchondrial percentage

```{r include=TRUE, echo=TRUE}

FeaturePlot(object = filtered_data_object,
            reduction = "pca",
            features = "mitoPct",
            split.by = "orig.ident",
            order = TRUE)

DimHeatmap(object = filtered_data_object,
           dims = 1:9,
           cells = 500,
           balanced = TRUE,
           assays = "RNA",
           reduction = "pca"
           )

```

###   Elbow Plot  

    Decide how many PCs to use.
Using 20

```{r include = TRUE, echo = TRUE}

ElbowPlot(object = filtered_data_object, ndims = 50, reduction = "pca")
pcs = 20

```

###   *t*-SNE  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunTSNE(object = filtered_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "initial_tsne")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_tsne", group.by = "orig.ident")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_tsne", group.by = "Phase")

```

### UMAP  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunUMAP(object = filtered_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "initial_umap")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "orig.ident")
DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "Phase")
DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "Phase", split.by = "orig.ident")

```


#     Clustering 

## Find cell neighbors
  --> Uses pcs variable defined earlier

```{r include=TRUE, echo=TRUE}

filtered_data_object <- FindNeighbors(object = filtered_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

```

## Cluster cells based on neighborhood

```{r inclue = TRUE, echo = TRUE}

#for resolution, pick a few to start with and refine from there.
filtered_data_object <- FindClusters(object = filtered_data_object,
                                     resolution = c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.6, 1.0, 1.4),
                                     algorithm = 1,
                                     random.seed = 18)

#forgot how to set "seurat_clusters" variable to the resolution I'm using so this is for that
filtered_data_object <- FindClusters(object = filtered_data_object,
                                     resolution = 0.15,
                                     algorithm = 1,
                                     random.seed = 18)

```

## Select clustering resolution to test  
### Resolution picked: 0.15
```{r include = TRUE, echo = TRUE}

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15",
        split.by = "orig.ident") +
        ggtitle("Res = 0.15")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15",
        split.by = "Phase") +
        ggtitle("Res = 0.15")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15") +
        ggtitle("Res = 0.15")

```

### Other resolutions tested:
```{r include = TRUE, echo = TRUE}

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.1",
        split.by = "orig.ident") +
        ggtitle("Res = 0.1")



DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.2",
        split.by = "orig.ident") +
        ggtitle("Res = 0.2")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.2",
        split.by = "Phase") +
        ggtitle("Res = 0.2")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.25",
        split.by = "orig.ident") +
        ggtitle("Res = 0.25")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.3",
        split.by = "orig.ident") +
        ggtitle("Res = 0.3")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.4",
        split.by = "orig.ident") +
        ggtitle("Res = 0.4")

DimPlot(object = filtered_data_object,
        reduction = "initial_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.1",
        split.by = "orig.ident") +
        ggtitle("Res = 1")


```


### Integrating?
Not proceeding with integration on this data.
Wanted to try it for the sake of practice but ran into issues installing lisi library
```{r include = TRUE, echo = TRUE}




```




#     Covariate check of clusters     

##Feature plots

* nCount_RNA  (reads)
* nFeature_RNA  (genes)
* mitoPct  (percent mito genes)

```{r include = TRUE, echo = TRUE}

FeaturePlot(object = filtered_data_object,
            reduction = "initial_umap",
            features = "nCount_RNA",
            split.by = "orig.ident",
            order = TRUE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = filtered_data_object,
            reduction = "initial_umap",
            features = "nFeature_RNA",
            split.by = "orig.ident",
            order = TRUE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = filtered_data_object,
            reduction = "initial_umap",
            features = "mitoPct",
            split.by = "orig.ident",
            order = TRUE) + theme(legend.position = c(0.8,0.9))
``` 

## IDing clusters based on commonly expressed genes

  cluster 5 = RBCs (Hba-a1 = hemoglobin)
  cluster 6,8 = CD163l1 -> some sort of fetal-derived CD8s
  cluster 7 = Macrophages/B cells (H2-Ab1 = MHC class II), Spi1 is a B cell/Myeloid dev marker, Ms4a1 is CD20
  Part of cluster 1 will probably be removed later after I reclusters T cells
  
  Based on above and CD8 and CD3e expression, clusters 0-4 are what I want

```{r include = TRUE, echo = TRUE}

VlnPlot(filtered_data_object, features = c("Cd19","Ms4a1","Hba-a1", "H2-Ab1","Ncr1","Cd3e","Cd8a","Spi1", "Cd4", "Cd24a", "Ikzf2", "Cd163l1","Igf1r","St6galnac3", "Itgal", "Itgam", "Fcgr3a"),group.by = "seurat_clusters", combine = FALSE)


``` 


## Identify doublets

```{r include = TRUE, echo = TRUE, eval = TRUE}

scDblObj <- scDblFinder(as.SingleCellExperiment(filtered_data_object), samples = "orig.ident")

filtered_data_object <- AddMetaData(filtered_data_object,
                                 metadata = as.data.frame(scDblObj@colData[,c("scDblFinder.class", "scDblFinder.score", "scDblFinder.weighted", "scDblFinder.cxds_score", "scDblFinder.sample")]))

table(filtered_data_object@meta.data$scDblFinder.class,
      filtered_data_object@meta.data$scDblFinder.sample)

#I have some doublets
DimPlot(object = filtered_data_object, reduction = "initial_umap",
       group.by = "scDblFinder.class", split.by = "orig.ident", order = TRUE)

Idents(filtered_data_object) <- "scDblFinder.class"

filtered_data_object <- subset(x = filtered_data_object, idents = "singlet")

#doublet have been removed - yes, this is the same code as above
table(filtered_data_object@meta.data$scDblFinder.class,
      filtered_data_object@meta.data$scDblFinder.sample)

DimPlot(object = filtered_data_object, reduction = "initial_umap",
       group.by = "scDblFinder.class", split.by = "orig.ident", order = TRUE)
```

#     Create new (2nd) Seurat Object for the T cell clusters only (clusters 0-4).
      Will recluster and see if there' anything else I need to get rid of.

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- filtered_data_object %>% subset(seurat_clusters %in% c("0","1","2","3","4"))

table(Tcell_data_object@meta.data$RNA_snn_res.0.15, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@meta.data$Phase, Tcell_data_object@meta.data$genotype)

#Ok. Non-Tcell clusters have been removed. 

```

##    ReRun t-SNE, UMAP, and clustering for Tcell only data
###   PCs - still 20
```{r include = TRUE, echo = TRUE}

ElbowPlot(object = Tcell_data_object, ndims = 50, reduction = "pca")
pcs = 20

Tcell_data_object <- RunPCA(object = Tcell_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)

Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

```
### t-SNE    
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunTSNE(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "Tcell_tsne")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "orig.ident")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "Phase")

```

### UMAP  
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunUMAP(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "Tcell_umap")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "orig.ident")

```


##    Re-Clustering

###   Resolution using = 0.05 (241213)

```{r include = TRUE, echo = TRUE}
Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = 0.05,
                                     algorithm = 1,
                                     random.seed = 18)


DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.05",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.05")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.05",
        split.by = "Phase") +
        ggtitle("Resolution = 0.05")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "orig.ident",
        split.by = "Phase") +
        ggtitle("Resolution = 0.05")

# Get number of cells per cluster and per sample of origin
table(Tcell_data_object@meta.data$RNA_snn_res.0.05, Tcell_data_object@meta.data$orig.ident)

Idents(object = Tcell_data_object) <- "RNA_snn_res.0.05"
```

###   Other resolutions tested

```{r include = TRUE, echo = TRUE}

pcs <- 20

#clustering
Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = c(0.05, 0.1,0.15, 0.2,0.225, 0.25,0.275, 0.3, 0.4),
                                     algorithm = 1,
                                     random.seed = 18)

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.05",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.1")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.2",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.2")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.275") +
        ggtitle("Resolution = 0.275")



#NOTE: Moving forward, after some troubleshooting and analyses downstream of higher resolutions. Choosing resolution 0.1. To get 4 clusters. Two clusters are in G1 and two clusters are dividing.

```



##    T cell UMAP if needed
```{r include = TRUE, echo = TRUE}

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.05",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.05")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        group.by = "Phase",
        split.by = "orig.ident", cols = c("gray", "orange", "#009E73")) + 
        theme(strip.text.x = element_text(size = 20, face = "bold") ) +
        ggtitle("") + xlab("Tcell UMAP 1") + ylab("Tcell UMAP 2")

```


#     T Cell cluster wrangling
          Resolution = 0.05 (This has been 0.1 before. Looking for 4 total clusters: naive and 3 activated. 2 G1 clusters, 2                    dividing)
##   Identify Naive T cell cluster based on Lef1 and Tcf7 expression.
```{r include = TRUE, echo = TRUE}

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Lef1",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Tcf7",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

```

##    Label cells as Naive and activated. Made new seurat objects to do this (probably an easier way?). Recombined and replaced           Tcell_data_object
      Can save Naive and activated groups of cells as RDS files, if wanted for some type of analysis that way.

```{r include = TRUE, echo = TRUE}
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")

#naive
Naive_data_object <- Tcell_data_object %>% subset(seurat_clusters %in% c("0"))
Naive_data_object <- AddMetaData(Naive_data_object, metadata = "naive", col.name = "activation_status")

#save/load if needed
#saveRDS(object = Naive_data_object, "~/Desktop/Opa1_scRNAseq/241207_naive_object_phase_regress.RDS")
#Naive_data_object <- readRDS("~/Desktop/Opa1_scRNAseq/241207_naive_object_phase_regress.RDS")

#activated
Activated_data_object <- Tcell_data_object %>% subset(seurat_clusters %in% c("1", "2", "3"))
Activated_data_object <- AddMetaData(Activated_data_object, metadata = "activated", col.name = "activation_status")

#Save/load if needed
#saveRDS(object = Activated_data_object, "~/Desktop/Opa1_scRNAseq/241207_activated_object_phase_regress.RDS")
#Activated_data_object <- readRDS("~/Desktop/Opa1_scRNAseq/241207_activated_object_phase_regress.RDS")


#Merge data back together
Tcell_data_object <- merge(x = Naive_data_object,
                           y = Activated_data_object)

Tcell_data_object <- JoinLayers(Tcell_data_object)

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
table(Tcell_data_object@meta.data$activation_status, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@active.ident, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@active.ident, Tcell_data_object@meta.data$activation_status)


```

##    Clean up metadata - remove unused columns
          Tried a few ways. This worked. Not efficient, I know.
```{r include = TRUE, echo = TRUE}

Tcell_data_object

Tcell_data_object$RNA_snn_res.0.05 <- NULL
Tcell_data_object$RNA_snn_res.0.2 <- NULL
Tcell_data_object$RNA_snn_res.0.3 <- NULL
Tcell_data_object$RNA_snn_res.0.4 <- NULL
Tcell_data_object$RNA_snn_res.0.6 <- NULL
Tcell_data_object$RNA_snn_res.1 <- NULL
Tcell_data_object$RNA_snn_res.1.4 <- NULL
Tcell_data_object$RNA_snn_res.0.25 <- NULL
Tcell_data_object$RNA_snn_res.0.15 <- NULL
Tcell_data_object$RNA_snn_res.0.225 <- NULL
Tcell_data_object$RNA_snn_res.0.275 <- NULL
Tcell_data_object$RNA_snn_res.0.175 <- NULL
Tcell_data_object$RNA_snn_res.0.18 <- NULL
Tcell_data_object$RNA_snn_res.0.19 <- NULL
Tcell_data_object$scDblFinder.class <- NULL
Tcell_data_object$scDblFinder.weighted <- NULL
Tcell_data_object$scDblFinder.score <- NULL
Tcell_data_object$scDblFinder.sample <- NULL
Tcell_data_object$scDblFinder.cxds_score <- NULL

#good to check. Other metadata columns look good
Tcell_data_object

```

##     Redo PCAs for Tcell_data_object 
```{r include = TRUE, echo=TRUE}
# TO DO
#2000 genes is a good starting point, no real need to use 5k or more
#FindVariableFeatures knows to use the normalized data. Back end Seurat stuff going on here, don't really need to worry about that
Tcell_data_object <- FindVariableFeatures(object = Tcell_data_object,
                                             selection.method = "vst",
                                             nfeatures = 2000,
                                             verbose = FALSE,
                                             assay = "RNA")

head(VariableFeatures(object = Tcell_data_object,
                 selection.method = "vst",
                 assay = "RNA"))

# TO DO : EXPLORE YOUR VARIABLE FEATURES -- ARE THESE THE GENES YOU WANT TO USE FOR CLUSTERING?

variableGeneDf <- as_tibble(HVFInfo(Tcell_data_object,
                                    selection.method = "vst",
                                    status = TRUE,
                                    assay = "RNA"),
                                    rownames = "Gene")

variableGeneDf = variableGeneDf %>%
  mutate(hypervariable=Gene %in%
           VariableFeatures(Tcell_data_object,
                            selection.method = "vst",
                            assay = "RNA"))

ggplot(variableGeneDf, aes(x = log(mean),
                       y = log(variance),
                       color = hypervariable)) +
                       geom_point()

```


###    Scale the data 
          This may not be needed? since it was scaled earlier?
          *Regress out cell cycle

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- ScaleData(object = Tcell_data_object,
                                  assay = "RNA",
                                  vars.to.regress = "Phase")


```

###    Calculate principle components 

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunPCA(object = Tcell_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)


```

###    Decide how many PCs to use.
          Using 20

```{r include = TRUE, echo = TRUE}

ElbowPlot(object = Tcell_data_object, ndims = 50, reduction = "pca")
pcs = 20

```

###    t-SNE    
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunTSNE(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "Tcell_tsne")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "orig.ident")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "Phase")

```

###    UMAP  
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunUMAP(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "Tcell_umap")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "orig.ident")

```


##      Re-Clustering T cell object
###     Resolution using = 0.1
```{r include = TRUE, echo = TRUE}
Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = 0.1,
                                     algorithm = 1,
                                     random.seed = 18)
#
DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        cols = c("Sky Blue", "Black"),
        label = FALSE,
        label.size = 6,
        group.by = "orig.ident") +
        ggtitle("")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.1") +
        ggtitle("")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "Phase",
        split.by = "orig.ident") +
        ggtitle("Cell cycle phase by genotype")

# Get number of cells per cluster and per sample of origin
table(Tcell_data_object@meta.data$RNA_snn_res.0.1, Tcell_data_object@meta.data$orig.ident)

Idents(object = Tcell_data_object) <- "RNA_snn_res.0.1"
```
####    Other resolutions tested (0.15 0.2 0.25)
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = c(0.1, 0.15, 0.2,0.3),
                                     algorithm = 1,
                                     random.seed = 18)

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.1",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.1")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.15")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.3",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.3")

```

##    Renaming T cell clusters (4 of them)

```{r include = TRUE, echo = TRUE}

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Lef1",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

cluster_names <- c("Naive","d5_dividing", "d5_G1","d5_opa1_unique")

#This will rename the factors in seurat_clusters to the names I put in the list from the last command
levels(Tcell_data_object@meta.data$seurat_clusters) <- as.factor(cluster_names)

#Active ident set to the new set of cluster names too
levels(Tcell_data_object@active.ident) <- as.factor(cluster_names)
```



##    Removing the WT cells in the opa1_unique cluster (has popped up before. Not needed 241213)
```{r include = TRUE, echo = TRUE}

#found the wt cell in this clusters: "wt_TGTTACTTCACAATGC"
head(WhichCells(Tcell_data_object, ident = "d5_opa1_unique"), 10)
#toRemove <- "wt_TGTTACTTCACAATGC"

#wt cell has been removed
#Tcell_data_object <- Tcell_data_object[, !colnames(Tcell_data_object) %in% toRemove]
table(Tcell_data_object@meta.data$RNA_snn_res.0.1, Tcell_data_object@meta.data$orig.ident)

```








#    Managing memory and space

```{r include=TRUE, echo=TRUE}

#Removing merged and filtered data objects - we've gotten to a good spot with our clusters and groups
#Removing Activated and Naive data objects - those can be rederived, if wanted.
#Don't need the dublets ID data
rm(Activated_data_object, Naive_data_object, filtered_data_object, merged_data_object, scDblObj, cluster_names)
gc()


```




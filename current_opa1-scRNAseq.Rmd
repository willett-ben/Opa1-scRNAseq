---
title: "BW2310 Opa1 scRNAseq d5"
author: "Ben Willett"
date: "250217"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
---


##    Notes:
- Regress out cell cycle at the beggining
- Cluster and remove contaminates
- Split naive and activated CD8s. Label in metadata
- Recombine objects so I can show violin plots for naive and activated cells
- I needed to redo the FindVariableFeatures(), scaling, etc. after I added the 'naive' and 'activated' labels to my cells
  
#     Install/Load packages (STEP 0)
This section is always required.  You will load all packages necessary for the scope of the assignment in between the code blocks.  

```{r, include =TRUE, echo=TRUE, message = FALSE}
# load packages here
library(SingleCellExperiment) #done
library(Seurat) #done
library(tidyverse) #done
library(Matrix) #done
library(scales) #done
library(cowplot) #done
library(RCurl) #done
library(AnnotationHub) #done
library(AnnotationFilter) #done
library(AnnotationDbi) #done
library(ensembldb) #done
library(SeuratWrappers) #done
library(harmony) #done
library(ggpubr) #done
library(gridExtra) #done
library(metap) #done
library(VISION) #done
library(clusterProfiler) #done
library(ggsci) #done
#library(lisi) #no but I don't think I need it
library(MetBrewer) #done
library(wesanderson) #done
library(scDblFinder) #done

#for later pathway analysis (taken from SBT's code)
library(readxl)
library(org.Mm.eg.db)
library(patchwork)
library(writexl)
library(fgsea)

#cNMF
library(readr)
library(dplyr)

#gsea heatmaps
library(RColorBrewer)
library(pheatmap)

```

#     Read in Data 

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
#path to 10X data
opa1_directory <- "~/Sandbox/opa1-scRNAseq-local/10X_data/opa1/10X_files"
wt_directory <-"~/Sandbox/opa1-scRNAseq-local/10X_data/wt/10X_files"

opa1 <- Read10X(data.dir = opa1_directory, unique.features = TRUE, strip.suffix = TRUE)
wt <- Read10X(data.dir = wt_directory, unique.features = TRUE, strip.suffix = TRUE)
```

#     Generate Seurat Objects
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

wt_obj <- CreateSeuratObject(counts = wt, project = "wt")
opa1_obj <- CreateSeuratObject(counts = opa1, project = "opa1")

```

#     Check metadata  
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

head(wt_obj@meta.data)
tail(wt_obj@meta.data)

head(opa1_obj@meta.data)
tail(opa1_obj@meta.data)

dim(wt_obj@meta.data) #7500 cells in WT sample
dim(opa1_obj@meta.data) #6700 cells in Opa1 sample

#confirm row names = gene names
row.names(wt_obj@assays$RNA)
row.names(opa1_obj@assays$RNA) 

#confirm col names = cell barcodes
colnames(wt_obj@assays$RNA) 
colnames(opa1_obj@assays$RNA)

```

      Total reads across cells

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
sum(wt_obj@meta.data$nCount_RNA)
sum(opa1_obj@meta.data$nCount_RNA)
```

#     Add sample specific metadata
##    Add genotype id 
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

wt_obj <- AddMetaData(wt_obj, metadata = "wt", col.name = "genotype")
opa1_obj <- AddMetaData(opa1_obj, metadata = "opa1", col.name = "genotype")

```

#     Merge Data
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

merged_data_object <- merge(x = wt_obj,
                            y = opa1_obj,
                            add.cell.id = c("wt", "opa1"))

merged_data_object <- JoinLayers(merged_data_object)

```

##    Confirm merge success  

```{r include = TRUE, echo = TRUE}

head(merged_data_object@meta.data)
tail(merged_data_object@meta.data)

#confirm same cell numbers from individual wt/opa1 seurat objects
table(merged_data_object@meta.data$orig.ident)

```

#     Managing memory and space - post merge
```{r include=TRUE, echo=TRUE}
rm(wt, wt_obj, opa1, opa1_obj, wt_directory, opa1_directory)
gc()
```

#     Data Setup and Formatting 
## Calculating per cell complexity, add to metadata 
```{r include = TRUE, echo = TRUE}

merged_data_object <- AddMetaData(object = merged_data_object,
                                  metadata = log10(merged_data_object$nFeature_RNA)/log10(merged_data_object$nCount_RNA),col.name = "complexity")

```

## Calculating mitochondrial read percentage per cell and adding this to the metadata  
```{r include = TRUE, echo = TRUE}

#"mt-" is the identifier for mitochondrial genes in this set
grep(rownames(merged_data_object@assays$RNA), pattern = "mt-", value = TRUE)


#Adding mitoPct to the metadata 
merged_data_object$mitoPct <- PercentageFeatureSet(object = merged_data_object, pattern = "mt-")

```

#     Initial Data Exploration 
##    Total Cells per Sample  
```{r include = TRUE, echo = TRUE}

ggplot(merged_data_object@meta.data, aes(x=orig.ident, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle("Number of Cells Per Sample (raw)")

```

##    Distribution of total number of reads per cell  
```{r include = TRUE, echo = TRUE}

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic() +
ylab("Cell density") +
ggtitle("Distribution of reads per cell across samples")

```

##    Distribution of total number of unique genes expressed per cell  
```{r include = TRUE, echo = TRUE}

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) +
 geom_density(alpha = 0.2) +
 theme_classic() +
 scale_x_log10() +
ggtitle("Distribution of total unique genes per cell across samples")

#Boxplot

ggplot(merged_data_object@meta.data, aes(x=orig.ident, y=log10(nFeature_RNA), fill=orig.ident)) +
geom_boxplot() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle("Distribution of unique genes expressed per cell (raw)")


```

##    Joint plot of reads, genes, and mitochondrial percentage  
```{r include = TRUE, echo = FALSE, message = FALSE, warning=FALSE}

ggplot(merged_data_object@meta.data, aes(x=nCount_RNA, y=nFeature_RNA, color=mitoPct)) +
   geom_point() +
   scale_colour_gradient(low = "gray90", high = "black") +
   stat_smooth(method=lm) +
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(~orig.ident)

```


##    Distribution of mitochondrial percent per cell  

      #Expected that the Opa1ko have even less mito chontamination than wt because the MITOCHONDRIAL GENOME IS        NOT MAINTAINED in Opa1ko cells!!
```{r include=TRUE, echo=TRUE, warning = FALSE}

ggplot(merged_data_object@meta.data, aes(color=orig.ident, x=mitoPct, fill=orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic()+
ggtitle("Distribution of mitochondrial contamination per cell across samples")

```

##    Distribution of library complexity per cell
```{r include=TRUE, echo=TRUE}

ggplot(merged_data_object@meta.data, aes(x=complexity, color = orig.ident, fill=orig.ident)) +
        geom_density(alpha = 0.2) +
        theme_classic() + 
  ggtitle("Distribution of complexity across samples")

```

##    Other plots  
      violin plots of prev data
```{r include=TRUE, echo=TRUE}

VlnPlot(merged_data_object, features = c("nFeature_RNA", "nCount_RNA", "mitoPct"), ncol = 3)
VlnPlot(merged_data_object, features = c("nFeature_RNA", "nCount_RNA", "mitoPct"), stack = T)

```

#     Filtering 
##    Cell-Level filtering

* keep cells with at least 200 unique genes present per cell  
* keep cells with at 1000 reads present per cell  
* keep cells that have a mitochondrial contamination percent of less than 20%  
* keep cell with a complexity of greater than 80%  


```{r include = TRUE, echo = TRUE}

filtered_data_object <- subset(x = merged_data_object,
                               subset = 
                                 (nFeature_RNA >= 2000) &
                                 (nCount_RNA >= 8500) &
                                 (mitoPct < 10) &
                                 (complexity > 0.75))
```

* The total number of cells before filtering  
* The total number of cell after filtering  

```{r include = TRUE, echo = TRUE}

paste("The number of cells prior to filtering:")
dim(merged_data_object@meta.data)[1]

paste("The number of cells after filtering:")
dim(filtered_data_object@meta.data)[1]

```

##    Gene-Level filtering  

Remove the following genes:
* that have 0 counts across all cells  
* not present in at least 10 cells  

```{r include = TRUE, echo = TRUE}

#count variable:
#row names = gene
#col names = cells

counts <- LayerData(filtered_data_object, assay = "RNA", layer = "counts")

nonzero <- counts > 0
nonzero

#filter out everything with less than 10 reads across all cells
less_10 <- Matrix::rowSums(nonzero) >= 10
less_10_matrix <- counts[less_10,]

#Using 10 as cutoff
keep_genes <- Matrix::rowSums(nonzero) >= 10
filtered_counts <- counts[keep_genes, ]
head(filtered_counts)

#32285 genes prior to filtering
dim(filtered_data_object@assays$RNA@features)

#13752 genes have been removed via this filtering
#less_10_matrix is the genes that remain after filtering. so ~18k genes remain after filtering
print(dim(filtered_data_object@assays$RNA@features)[1] - dim(less_10_matrix)[1])


filtered_data_object <- CreateSeuratObject(counts = filtered_counts, meta.data = filtered_data_object@meta.data)
```


#     Post-Filtering Data Exploration  
##    Total Cells per Sample  
```{r include = TRUE, echo = TRUE}

ggplot(filtered_data_object@meta.data, aes(x=orig.ident, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

```
 
##    Distribution of total number of reads per cell  

```{r include = TRUE, echo = TRUE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density") +
  geom_vline(xintercept = 1000, linetype = "dashed", color = "orange", linewidth = 2)

```
##    Distribution of total number of unique genes expressed per cell  

```{r include = TRUE, echo = TRUE, warning=FALSE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density")

```

##    Joint plot of reads, genes, and mitochondrial percentage  

```{r include = TRUE, echo = TRUE, warning=FALSE, message=FALSE}

ggplot(filtered_data_object@meta.data, aes(x=nCount_RNA, y=nFeature_RNA, color=mitoPct)) +
   geom_point() +
   scale_colour_gradient(low = "gray90", high = "black") +
   stat_smooth(method=lm) + #throws in linear model line (blue line)
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(~orig.ident)

```

##    Distribution of mitochondrial percent per cell  

```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(filtered_data_object@meta.data, aes(color=orig.ident, x=mitoPct, fill=orig.ident)) +
geom_density(alpha = 0.2) +
scale_x_log10() +
theme_classic() +
geom_vline(xintercept = 20, linetype = "dashed", color = "orange", linewidth = 2)

```

##    Distribution of library complexity per cell  

```{r include=TRUE, echo=TRUE}

ggplot(filtered_data_object@meta.data, aes(x=complexity, color=orig.ident, fill=orig.ident)) +
        geom_density(alpha = 0.2) +
theme_classic()

```

##    Other plots  

```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}

VlnPlot(filtered_data_object, features = c("nCount_RNA", "nFeature_RNA", "mitoPct"), ncol = 3)
VlnPlot(filtered_data_object, features = c("nCount_RNA", "nFeature_RNA", "mitoPct"), stack = T)

```


##    Managing memory and space  .   

```{r include=TRUE, echo=TRUE}

#going to keep the merged_data_object in case I need to go back and refilter things
rm(nonzero, keep_genes, counts, filtered_counts, less_10_matrix, less_10)
gc()

```

#     Normalization and gene score calculations   
      Now that we have visually identified some cell-level thresholds  

##    Gene expression normalization  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- NormalizeData(object = filtered_data_object,
                                      normalization.method = "LogNormalize",
                                      assay = "RNA")

#sanity check. All are floats/continuous values. The raw data is integers
filtered_data_object@assays$RNA@layers

```

## Calculate cell cycling scores    

```{r include = TRUE, echo = TRUE}

#cycling genes:
cc.genes.updated.2019

filtered_data_object <- CellCycleScoring(object = filtered_data_object,
                                         g2m.features = cc.genes.updated.2019$g2m.genes,
                                         s.features = cc.genes.updated.2019$s.genes)
#check
head(filtered_data_object@meta.data)

```

###   Distribution of cells per phase

```{r include = TRUE, echo = TRUE}

#X is phase
ggplot(filtered_data_object@meta.data, aes(x=Phase, fill=orig.ident)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

#X is genotype
ggplot(filtered_data_object@meta.data, aes(x=orig.ident, fill=Phase)) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))
```  

#     PCA 

##    Identify most variable genes  
      Use standard 2000 most variable genes:

```{r include = TRUE, echo=TRUE}

filtered_data_object <- FindVariableFeatures(object = filtered_data_object,
                                             selection.method = "vst",
                                             nfeatures = 2000,
                                             verbose = FALSE,
                                             assay = "RNA")

VariableFeatures(object = filtered_data_object,
                 selection.method = "vst",
                 assay = "RNA")

#check that these genes are ok to be used for clustering
variableGeneDf <- as_tibble(HVFInfo(filtered_data_object,
                                    selection.method = "vst",
                                    status = TRUE,
                                    assay = "RNA"),
                                    rownames = "Gene")

variableGeneDf = variableGeneDf %>%
  mutate(hypervariable=Gene %in%
           VariableFeatures(filtered_data_object,
                            selection.method = "vst",
                            assay = "RNA"))

ggplot(variableGeneDf, aes(x = log(mean),
                       y = log(variance),
                       color = hypervariable)) +
                       geom_point()

```

##    Scale the data 
      Regress out cell cycle

```{r include = TRUE, echo = TRUE}

filtered_data_object <- ScaleData(object = filtered_data_object,
                                  assay = "RNA",
                                  vars.to.regress = "Phase")

```

##    Calculate principle components 

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunPCA(object = filtered_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)


```

##    Visualizing of principle components  
###   Dim Plots
      * Phase  
      * stimulation_status  
      * orig.ident  

```{r include=TRUE, echo=TRUE}

DimPlot(filtered_data_object, reduction = "pca", group.by = "Phase", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", split.by = "Phase", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", group.by = "orig.ident", order = TRUE)
DimPlot(filtered_data_object, reduction = "pca", group.by = "Phase", split.by = "orig.ident", order = TRUE)

```

###   FeaturePlots

      *  mitchondrial percentage

```{r include=TRUE, echo=TRUE}

FeaturePlot(object = filtered_data_object,
            reduction = "pca",
            features = "mitoPct",
            split.by = "orig.ident",
            order = TRUE)

DimHeatmap(object = filtered_data_object,
           dims = 1:9,
           cells = 500,
           balanced = TRUE,
           assays = "RNA",
           reduction = "pca"
           )

```

###   Elbow Plot  

    Decide how many PCs to use.
    Using 20

```{r include = TRUE, echo = TRUE}

ElbowPlot(object = filtered_data_object, ndims = 50, reduction = "pca")
pcs = 20

```

###   *t*-SNE  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunTSNE(object = filtered_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "initial_tsne")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_tsne", group.by = "orig.ident")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_tsne", group.by = "Phase")

```

### UMAP  

```{r include = TRUE, echo = TRUE}

filtered_data_object <- RunUMAP(object = filtered_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "initial_umap")

DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "orig.ident")
DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "Phase")
DimPlot(object = filtered_data_object, dims = 1:2, reduction = "initial_umap", group.by = "Phase", split.by = "orig.ident")

```


#     Clustering 

##    Find cell neighbors
      --> Uses pcs variable defined earlier

```{r include=TRUE, echo=TRUE}

filtered_data_object <- FindNeighbors(object = filtered_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

```

##   Load filtered data object
```{r include = TRUE, echo = TRUE}
seurat_directory <- "~/Sandbox/opa1-scRNAseq-local/seurat_objects/"
seurat_object_load <- "filtered_data_object.RDS"

filtered_data_object <- readRDS(paste0(seurat_directory, seurat_object_load))
```

##      Select clustering resolution to test  
###         Resolutions tested:
            0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.6, 1.0, 1.4
            
```{r include = TRUE, echo = TRUE}
resolutions_to_test <- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.6, 1.0, 1.4)

filtered_data_object <- FindClusters(object = filtered_data_object,
                                     resolution = resolutions_to_test,
                                     algorithm = 1,
                                     random.seed = 18)

plot_list <- list()
i <-1 
for (res in resolutions_to_test) {
  plot <-   DimPlot(object = filtered_data_object,
              reduction = "initial_umap",
              label = FALSE,
              label.size = 6,
              group.by = paste0("RNA_snn_res.", res),
              split.by = "orig.ident") +
              ggtitle(paste0("Res = ", res))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

```
###         Resolution picked: 0.15

```{r include = TRUE, echo = TRUE}

final_resolution <- "0.15"

#double check. Looks good.
resolution_plots <- list("orig.ident", "Phase", NULL)
plot_list <- list()
i <- 1
for (grouping in resolution_plots) {
  plot <-   DimPlot(object = filtered_data_object,
              reduction = "initial_umap",
              label = FALSE,
              label.size = 6,
              group.by = paste0("RNA_snn_res.", final_resolution),
              split.by = grouping) +
              ggtitle(paste0("Res = ", final_resolution, " (Resolution chosen)"))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

```
###         Cleanup variables

```{r include = TRUE, echo = TRUE}
rm(grouping, i, res, final_resolution, resolutions_to_test)
gc()
``` 

#     Covariate check of clusters     

##      Feature plots

          * nCount_RNA  (reads)
          * nFeature_RNA  (genes)
          * mitoPct  (percent mito genes)

```{r include = TRUE, echo = TRUE}
covariate_checks <- list("nCount_RNA", "nFeature_RNA", "mitoPct")
plot_list <- list()
i <- 1
for (covariate in covariate_checks) {
  plot <-   FeaturePlot(object = filtered_data_object,
              reduction = "initial_umap",
              features = covariate,
              split.by = "orig.ident",
              order = TRUE) + theme(legend.position = c(0.8,0.9))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

rm(covariate_checks, plot_list, i)

``` 

## IDing clusters based on commonly expressed genes

  cluster 5 = RBCs (Hba-a1 = hemoglobin)
  cluster 6,8 = CD163l1 -> some sort of fetal-derived CD8s
  cluster 7 = Macrophages/B cells (H2-Ab1 = MHC class II), Spi1 is a B cell/Myeloid dev marker, Ms4a1 is CD20
  Part of cluster 1 will probably be removed later after I reclusters T cells
  
  Based on above and CD8 and CD3e expression, clusters 0-4 are what I want

```{r include = TRUE, echo = TRUE}
genes_for_IDing <- c("Cd19","Ms4a1","Hba-a1", "H2-Ab1","Ncr1","Cd3e","Cd8a","Spi1", "Cd4", "Cd24a", "Ikzf2", "Cd163l1","Igf1r","St6galnac3", "Itgal", "Itgam")



plot_list <- list()
i <- 1
for (gene in genes_for_IDing) {
  plot <- VlnPlot(filtered_data_object, features = gene ,group.by = "seurat_clusters", combine = FALSE)
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

rm(genes_for_IDing, plot_list, i)

``` 


## Identify doublets

```{r include = TRUE, echo = TRUE, eval = TRUE}

scDblObj <- scDblFinder(as.SingleCellExperiment(filtered_data_object), samples = "orig.ident")

filtered_data_object <- AddMetaData(filtered_data_object,
                                 metadata = as.data.frame(scDblObj@colData[,c("scDblFinder.class", "scDblFinder.score", "scDblFinder.weighted", "scDblFinder.cxds_score", "scDblFinder.sample")]))

table(filtered_data_object@meta.data$scDblFinder.class,
      filtered_data_object@meta.data$scDblFinder.sample)

#I have some doublets
DimPlot(object = filtered_data_object, reduction = "initial_umap",
       group.by = "scDblFinder.class", split.by = "orig.ident", order = TRUE)

Idents(filtered_data_object) <- "scDblFinder.class"

filtered_data_object <- subset(x = filtered_data_object, idents = "singlet")

#doublet have been removed - yes, this is the same code as above
table(filtered_data_object@meta.data$scDblFinder.class,
      filtered_data_object@meta.data$scDblFinder.sample)

DimPlot(object = filtered_data_object, reduction = "initial_umap",
       group.by = "scDblFinder.class", split.by = "orig.ident", order = TRUE)
```

#     Create new (2nd) Seurat Object for the T cell clusters only (clusters 0-4).
      Will recluster and see if there' anything else I need to get rid of.

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- filtered_data_object %>% subset(seurat_clusters %in% c("0","1","2","3","4"))

table(Tcell_data_object@meta.data$RNA_snn_res.0.15, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@meta.data$Phase, Tcell_data_object@meta.data$genotype)

#Ok. Non-Tcell clusters have been removed. 

```

##    ReRun t-SNE, UMAP, and clustering for Tcell only data
###   PCs - still 20
```{r include = TRUE, echo = TRUE}

ElbowPlot(object = Tcell_data_object, ndims = 50, reduction = "pca")
pcs = 20

Tcell_data_object <- RunPCA(object = Tcell_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)

Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

```

### t-SNE    
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunTSNE(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "Tcell_tsne")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "orig.ident")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "Phase")

```

### UMAP  
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunUMAP(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "Tcell_umap")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "orig.ident")

```


##    Re-Clustering

###   Resolution using = 0.05 (241213)

```{r include = TRUE, echo = TRUE}
Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = 0.05,
                                     algorithm = 1,
                                     random.seed = 18)


DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.05",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.05")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.05",
        split.by = "Phase") +
        ggtitle("Resolution = 0.05")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "orig.ident",
        split.by = "Phase") +
        ggtitle("Resolution = 0.05")

# Get number of cells per cluster and per sample of origin
table(Tcell_data_object@meta.data$RNA_snn_res.0.05, Tcell_data_object@meta.data$orig.ident)

Idents(object = Tcell_data_object) <- "RNA_snn_res.0.05"
```

###   Other resolutions tested

```{r include = TRUE, echo = TRUE}

pcs <- 20

#clustering
Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")


resolutions_to_test <- c(0.05, 0.1,0.15, 0.2,0.225, 0.25,0.275, 0.3, 0.4)

Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = resolutions_to_test,
                                     algorithm = 1,
                                     random.seed = 18)

plot_list <- list()
i <-1 
for (res in resolutions_to_test) {
  plot <-   DimPlot(object = Tcell_data_object,
              reduction = "initial_umap",
              label = FALSE,
              label.size = 6,
              group.by = paste0("RNA_snn_res.", res),
              split.by = "orig.ident") +
              ggtitle(paste0("Res = ", res))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}


Tcell_resolutions <- 0.1

#NOTE: Moving forward, after some troubleshooting and analyses downstream of higher resolutions. Choosing resolution 0.1. To get 4 clusters. Two clusters are in G1 and two clusters are dividing.

```



##    T cell UMAP if needed
```{r include = TRUE, echo = TRUE}

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.1",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.1")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        group.by = "Phase",
        split.by = "orig.ident", cols = c("gray", "orange", "#009E73")) + 
        theme(strip.text.x = element_text(size = 20, face = "bold") ) +
        ggtitle("") + xlab("Tcell UMAP 1") + ylab("Tcell UMAP 2")

```


#     T Cell cluster wrangling
          Resolution = 0.05 (This has been 0.1 before. Looking for 4 total clusters: naive and 3 activated. 2 G1 clusters, 2                    dividing)
##   Identify Naive T cell cluster based on Lef1 and Tcf7 expression.
```{r include = TRUE, echo = TRUE}

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Lef1",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Tcf7",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

```


##    Label cells as Naive and activated. Made new seurat objects to do this (probably an easier way?). Recombined and replaced           Tcell_data_object
      Can save Naive and activated groups of cells as RDS files, if wanted for some type of analysis that way.

```{r include = TRUE, echo = TRUE}
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")

#naive
Naive_data_object <- Tcell_data_object %>% subset(seurat_clusters %in% c("0"))
Naive_data_object <- AddMetaData(Naive_data_object, metadata = "naive", col.name = "activation_status")

#save/load if needed
#saveRDS(object = Naive_data_object, "~/Desktop/Opa1_scRNAseq/241207_naive_object_phase_regress.RDS")
#Naive_data_object <- readRDS("~/Desktop/Opa1_scRNAseq/241207_naive_object_phase_regress.RDS")

#activated
Activated_data_object <- Tcell_data_object %>% subset(seurat_clusters %in% c("1", "2", "3"))
Activated_data_object <- AddMetaData(Activated_data_object, metadata = "activated", col.name = "activation_status")

#Save/load if needed
#saveRDS(object = Activated_data_object, "~/Desktop/Opa1_scRNAseq/241207_activated_object_phase_regress.RDS")
#Activated_data_object <- readRDS("~/Desktop/Opa1_scRNAseq/241207_activated_object_phase_regress.RDS")


#Merge data back together
Tcell_data_object <- merge(x = Naive_data_object,
                           y = Activated_data_object)

Tcell_data_object <- JoinLayers(Tcell_data_object)

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
table(Tcell_data_object@meta.data$activation_status, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@active.ident, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@active.ident, Tcell_data_object@meta.data$activation_status)


```

##    Clean up metadata - remove unused columns

```{r include = TRUE, echo = TRUE}

Tcell_data_object

metadata_to_delete <- list("RNA_snn_res.0.05", 
                           "RNA_snn_res.0.2",
                           "RNA_snn_res.0.3",
                           "RNA_snn_res.0.4",
                           "RNA_snn_res.0.6",
                           "RNA_snn_res.1",
                           "RNA_snn_res.1.4",
                           "RNA_snn_res.0.25",
                           "RNA_snn_res.15",
                           "RNA_snn_res.225",
                           "RNA_snn_res.275",
                           "RNA_snn_res.175",
                           "scDblFinder.class",
                           "scDblFinder.weighted",
                           "scDblFinder.score",
                           "scDblFinder.sample",
                           "scDblFinder.cxds_score")


for (metadata in metadata_to_delete) {
  data_cat <- paste0("Tcell_data_object$", metadata, " <- NULL")
  eval(rlang::parse_expr(data_cat))
}

#good to check. Other metadata columns look good
Tcell_data_object

```

##   Load Tcell_data_object
```{r include = TRUE, echo = TRUE}
seurat_directory <- "~/Sandbox/opa1-scRNAseq-local/seurat_objects/"

Tcell_data_object <- readRDS(paste0(seurat_directory, "Tcell_data_obj.RDS"))
```

##     Redo PCAs for Tcell_data_object 
```{r include = TRUE, echo=TRUE}
# TO DO
#2000 genes is a good starting point, no real need to use 5k or more
#FindVariableFeatures knows to use the normalized data. Back end Seurat stuff going on here, don't really need to worry about that
Tcell_data_object <- FindVariableFeatures(object = Tcell_data_object,
                                             selection.method = "vst",
                                             nfeatures = 2000,
                                             verbose = FALSE,
                                             assay = "RNA")

head(VariableFeatures(object = Tcell_data_object,
                 selection.method = "vst",
                 assay = "RNA"))

# TO DO : EXPLORE YOUR VARIABLE FEATURES -- ARE THESE THE GENES YOU WANT TO USE FOR CLUSTERING?

variableGeneDf <- as_tibble(HVFInfo(Tcell_data_object,
                                    selection.method = "vst",
                                    status = TRUE,
                                    assay = "RNA"),
                                    rownames = "Gene")

variableGeneDf = variableGeneDf %>%
  mutate(hypervariable=Gene %in%
           VariableFeatures(Tcell_data_object,
                            selection.method = "vst",
                            assay = "RNA"))

ggplot(variableGeneDf, aes(x = log(mean),
                       y = log(variance),
                       color = hypervariable)) +
                       geom_point()

```


###    Scale the data 
          This may not be needed? since it was scaled earlier?
          *Regress out cell cycle

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- ScaleData(object = Tcell_data_object,
                                  assay = "RNA",
                                  vars.to.regress = "Phase")


```

###    Calculate principle components 

```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunPCA(object = Tcell_data_object,
                               assay = "RNA",
                               seed.use = 42,
                               npcs = 50,
                               weight.by.var = TRUE)


```

###    Decide how many PCs to use.
          Using 20

```{r include = TRUE, echo = TRUE}

ElbowPlot(object = Tcell_data_object, ndims = 50, reduction = "pca")
pcs = 20

```

###    t-SNE    
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunTSNE(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                seed.use = 42,
                                reduction.name = "Tcell_tsne")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "orig.ident")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_tsne", group.by = "Phase")

```

###    UMAP  
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- RunUMAP(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = "pca",
                                assay = "RNA",
                                n.neighbors = 30,
                                seed.use = 18,
                                reduction.name = "Tcell_umap")

DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "orig.ident")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase")
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "orig.ident")

```


##      Re-Clustering T cell object
###     Resolution using = 0.1
```{r include = TRUE, echo = TRUE}
Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = "pca",
                                      dims = 1:pcs,
                                      assay = "RNA")

Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = 0.1,
                                     algorithm = 1,
                                     random.seed = 18)
#
DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        cols = c("Sky Blue", "Black"),
        label = FALSE,
        label.size = 6,
        group.by = "orig.ident") +
        ggtitle("")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.1") +
        ggtitle("")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "Phase",
        split.by = "orig.ident") +
        ggtitle("Cell cycle phase by genotype")

# Get number of cells per cluster and per sample of origin
table(Tcell_data_object@meta.data$RNA_snn_res.0.1, Tcell_data_object@meta.data$orig.ident)

Idents(object = Tcell_data_object) <- "RNA_snn_res.0.1"
```
####    Other resolutions tested (0.15 0.2 0.25)
```{r include = TRUE, echo = TRUE}

Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = c(0.1, 0.15, 0.2,0.3),
                                     algorithm = 1,
                                     random.seed = 18)

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.1",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.1")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.15",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.15")

DimPlot(object = Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        label.size = 6,
        group.by = "RNA_snn_res.0.3",
        split.by = "orig.ident") +
        ggtitle("Resolution = 0.3")

```

##    Renaming T cell clusters (4 of them)

```{r include = TRUE, echo = TRUE}

FeaturePlot(object = Tcell_data_object,
            reduction = "Tcell_umap",
            features = "Lef1",
            split.by = "orig.ident",
            order = FALSE) + theme(legend.position = c(0.8,0.9))

cluster_names <- c("Naive","d5_dividing", "d5_G1","d5_opa1_unique")

#This will rename the factors in seurat_clusters to the names I put in the list from the last command
levels(Tcell_data_object@meta.data$seurat_clusters) <- as.factor(cluster_names)

#Active ident set to the new set of cluster names too
levels(Tcell_data_object@active.ident) <- as.factor(cluster_names)
```



##    Removing the WT cells in the opa1_unique cluster (has popped up before. Not needed 241213)
```{r include = TRUE, echo = TRUE}

#found the wt cell in this clusters: "wt_TGTTACTTCACAATGC"
head(WhichCells(Tcell_data_object, ident = "d5_opa1_unique"), 10)
toRemove <- "wt_TGTTACTTCACAATGC"

#wt cell has been removed
Tcell_data_object <- Tcell_data_object[, !colnames(Tcell_data_object) %in% toRemove]
table(Tcell_data_object@meta.data$RNA_snn_res.0.1, Tcell_data_object@meta.data$orig.ident)

```








#    Managing memory and space

```{r include=TRUE, echo=TRUE}
seurat_directory <- "~/Sandbox/opa1-scRNAseq-local/seurat_objects/"

#Removing merged and filtered data objects - we've gotten to a good spot with our clusters and groups
#Removing Activated and Naive data objects - those can be rederived, if wanted.
#Don't need the dublets ID data
rm(Activated_data_object, Naive_data_object, filtered_data_object, merged_data_object, scDblObj, cluster_names)
gc()

#Save/load if needed
saveRDS(object = Activated_data_object, paste0(seurat_directory, "activated_object_phase_regress.RDS"))
Activated_data_object <- readRDS(paste0(seurat_directory, "activated_object_phase_regress.RDS"))
```

#   Save/Load Tcell_data_object for analysis
    
```{r include=TRUE, echo=TRUE}
seurat_directory <- "~/Sandbox/opa1-scRNAseq-local/seurat_objects/"


saveRDS(object = Tcell_data_object, paste0(seurat_directory, "Tcell_data_obj_forAnalysis.RDS"))

Tcell_data_object <- readRDS(paste0(seurat_directory, "Tcell_data_obj_forAnalysis.RDS"))
```








Putting in some change here. Can I add this to the 'initial analysis branch'?


###   Figures for the paper
```{r include = TRUE, echo = TRUE}

DimPlot(Tcell_data_object,
        reduction = "Tcell_umap",
        label = FALSE,
        group.by = "activation_status") +
  ggtitle("title")

#Fig 6a
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "activation_status", cols = c("dark red","gray"))

#Fig 6b
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "genotype", cols = c("skyblue","black"))

#Fig 6c
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "seurat_clusters", split.by = "genotype", cols = c("black","lightgreen","beige","lightblue"))

#Fig 6d
ggplot(Tcell_data_object@meta.data, aes(x = seurat_clusters, fill = genotype)) + scale_fill_manual(values = c("skyblue","black"))+ geom_bar(position = "fill") + ylab("Proportion of Cluster")

#Fig 6e
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "genotype", cols = c("black","red","yellow"))

#Fig 6f
ggplot(Tcell_data_object@meta.data, aes(x = seurat_clusters, fill = Phase)) + scale_fill_manual(values = c("black","red","yellow"))+ geom_bar() + xlab("Cluster")

#Fig 6g
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "program", cols = c("lightblue","navy","orange","lightyellow","darkgreen"))

#Fig 6h
ggplot(Tcell_data_object@meta.data, aes(x = program, fill = genotype)) + scale_fill_manual(values = c("skyblue","black"))+ geom_bar(position = "fill")

#Fig 6i-j
ggplot(Tcell_data_object@meta.data, aes(x = program, fill = Phase)) + scale_fill_manual(values = c("black","red","yellow"))+ geom_bar() + facet_grid(. ~ genotype)



#Fig Supp 6E - hmmmmmmmmm
allMarkers <- FindAllMarkers(object = Tcell_data_object,
                             assay = "RNA",
                             logfc.threshold = 0.25,
                             test.use = "wilcox",
                             only.pos = FALSE,
                             verbose = TRUE)

top5perGEP <- allMarkers %>% group_by(cluster) %>% top_n(5, avg_log2FC)

DotPlot(object = Tcell_data_object, features = unique(top5perGEP$gene)) +
         theme(axis.text.x = element_text(angle = 45, hjust = 1))



```





#   Generate files for cNMF analysis
    
```{r include=TRUE, echo=TRUE}

filtered_dir = '/Users/ben/Documents/Sandbox/Opa1-scRNAseq/cnmf/'

counts_norm <- Tcell_data_object@assays$RNA$data
barcodes <- colnames(counts_norm)
gene_names <- rownames(counts_norm)

# Output counts matrix
writeMM(counts_norm, paste0(filtered_dir, 'matrix.mtx'))

# Output cell barcodes
write.table(as.data.frame(barcodes), paste0(filtered_dir, 'barcodes.tsv'),
           col.names = FALSE, row.names = FALSE, sep = "\t")

# Output feature names
features <- data.frame("gene_id" = gene_names,"gene_name" = gene_names,type = "Gene Expression")
write.table(as.data.frame(features), sep = "\t", paste0(filtered_dir, 'genes.tsv'),
           col.names = FALSE, row.names = FALSE)

```


NOTE: From here onwards, I am trying to replicate what R.M.K. did for the paper.
    So the pathway filtering isn't done in R, it's based on the hallmark pathways he showed in Fig 6K and
    pathways that he had sent me from my own analysis for me to investigate and categorize (Fig 6L)


##    cNMF
```{r include = TRUE, echo = TRUE}

system(command = "cnmf prepare --output-dir ~/Sandbox/0pa1-scRNAseq-local/cnmf/output/ --name opa1_cnmf -c ~/Documents/Sandbox/Opa1-scRNAseq/cnmf/matrix.mtx -k 4 5 6 --max-nmf-iter 2000 --n-iter 100 --numgenes 2000")

system(command = "cnmf factorize --output-dir ~/Sandbox/0pa1-scRNAseq-local/cnmf/output/ --name opa1_cnmf --worker-index 0 --total-workers 1")

system(command = "cnmf combine --output-dir ~/Sandbox/0pa1-scRNAseq-local/cnmf/output/ --name opa1_cnmf")


system(command = "cnmf k_selection_plot --output-dir ~/Sandbox/0pa1-scRNAseq-local/cnmf/output/ --name opa1_cnmf")

system(command = "cnmf consensus --output-dir ~/Sandbox/0pa1-scRNAseq-local/cnmf/output/ --name opa1_cnmf --components 5 --local-density-threshold 0.01 --show-clustering")



```


##    Load in cNMF outputs 
      Need local path to cNMF output files
```{r include = TRUE, echo = TRUE}
#directory with cNMF output files
cnmf_output_directory <- "~/Sandbox/opa1-scRNAseq-local/cnmf/output/opa1_cnmf/"


usage_file <- read.table(paste0(cnmf_output_directory, "opa1_cnmf.usages.k_5.dt_0_01.consensus.txt"), sep = '\t', row.names = 1, header = TRUE)

spectra_score <- read.table(paste0(cnmf_output_directory, "opa1_cnmf.gene_spectra_score.k_5.dt_0_01.txt"), sep = '\t', row.names = 1, header = TRUE)
  
spectra_tpm <- read.table(paste0(cnmf_output_directory, "opa1_cnmf.gene_spectra_tpm.k_5.dt_0_01.txt"), sep = '\t', row.names = 1, header = TRUE)

usage_norm <- as.data.frame(t(apply(usage_file, 1, function(x) x / sum(x))))

```


##   Add cNMF data into metadata of seurat obj and plot on UMAP
    
    IMPORTANT!
    Looks like there is a slight difference in the GEPs that my cNMF generated vs Ross's (his GEP5 is my GEP4)
    Coloring as appropriate on the UMAP
    Will be rearranging in the figures so that will be why the GEPs are labeled 1,2,3,5,4
```{r include = TRUE, echo = TRUE}

#rename usage_norm columns to GEPs
colnames(usage_norm) <- c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")

#needed to remove old GEP data form metadata
Tcell_data_object@meta.data$GEP1 <- NULL
Tcell_data_object@meta.data$GEP2 <- NULL
Tcell_data_object@meta.data$GEP3 <- NULL
Tcell_data_object@meta.data$GEP4 <- NULL
Tcell_data_object@meta.data$GEP5 <- NULL
Tcell_data_object@meta.data$max_category <- NULL


cnmf_metadata <- merge(Tcell_data_object@meta.data, usage_norm, by = "row.names", all.x = TRUE)

rownames(cnmf_metadata) <- cnmf_metadata$Row.names




cnmf_metadata <- cnmf_metadata %>%
  mutate(max_category = ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 1, "GEP1", 
                             ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 2, "GEP2",
                                    ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 3, "GEP3",
                                           ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 4, "GEP4","GEP5"))))) 
Tcell_data_object@meta.data <- cnmf_metadata

Tcell_data_object@meta.data$Row.names <- NULL

#Fig 6G
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "max_category", split.by = "genotype", cols = c("darkcyan","skyblue4","darkorange3","gold3", "seagreen"), pt.size = 0.8)

#Fig 6H
#paper has Opa1 on bottom but thats ok. This is the gist of the plot
ggplot(Tcell_data_object@meta.data, aes(x = max_category, fill = genotype)) + scale_fill_manual(values = c("skyblue2","black"))+ geom_bar(position = "fill") + ylab("Frequency (%)")

#Fig 6f - WT
ggplot(data = Tcell_data_object@meta.data[Tcell_data_object@meta.data$genotype == "wt",], aes(x = max_category, fill = Phase)) + scale_fill_manual(values = c("black","red","yellow"))+ geom_bar() + xlab("Cluster") + labs(title = "WT") + theme(plot.title = element_text(hjust = 0.5, size = 25))

#Fig 6f - opa1
ggplot(data = Tcell_data_object@meta.data[Tcell_data_object@meta.data$genotype == "opa1",], aes(x = max_category, fill = Phase)) + scale_fill_manual(values = c("black","red","yellow"))+ geom_bar() + xlab("Cluster") + labs(title = "Opa1") + theme(plot.title = element_text(hjust = 0.5, size = 25))

```


##   GSEA hallmark pathways (Fig 6K)
    RDS file downloaded from https://bioinf.wehi.edu.au/MSigDB/v7.1/ 
```{r include = TRUE, echo = TRUE}
#These were downloaded from https://bioinf.wehi.edu.au/MSigDB/v7.1/ 
MSigDB_directory <- "~/Sandbox/reference_data/MSigDB/"

Mm.h <- readRDS(file= paste0(MSigDB_directory, "Mm.h.all.v7.1.entrez.rds"))


scores <- t(spectra_score)
colnames(scores) <-  c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")

symbols <- rownames(scores)
IDs <- mapIds(org.Mm.eg.db, symbols, 'ENTREZID', 'SYMBOL')
scores_df <- as.data.frame(scores)
class(scores_df)
scores_df <- mutate(scores_df, 'Entrez ID' = IDs[rownames(scores_df)])
scores_df

#remove genes with no Entrez ID
scores_df <- scores_df[complete.cases(scores_df), ]

#order genes for GEP1
scores_df <- scores_df[order(scores_df$GEP1, decreasing = TRUE), ]

#rank genes for GEP1 gsea
ranks <- scores_df$GEP1
names(ranks) <- scores_df$`Entrez ID`
head(ranks)

GEP1_h_fgsea_results <- fgsea(pathways = Mm.h, stats = ranks, minSize = 15, maxSize = 500)


#order genes for GEP2
scores_df <- scores_df[order(scores_df$GEP2, decreasing = TRUE), ]

#rank genes for GEP2 gsea
ranks <- scores_df$GEP2
names(ranks) <- scores_df$`Entrez ID`
head(ranks)

GEP2_h_fgsea_results <- fgsea(pathways = Mm.h, stats = ranks, minSize = 15, maxSize = 500)


#order genes for GEP3
scores_df <- scores_df[order(scores_df$GEP3, decreasing = TRUE), ]

#rank genes for GEP3 gsea
ranks <- scores_df$GEP3
names(ranks) <- scores_df$`Entrez ID`

GEP3_h_fgsea_results <- fgsea(pathways = Mm.h, stats = ranks, minSize = 15, maxSize = 500)


#order genes for GEP4
scores_df <- scores_df[order(scores_df$GEP4, decreasing = TRUE), ]

#rank genes for GEP4 gsea
ranks <- scores_df$GEP4
names(ranks) <- scores_df$`Entrez ID`

GEP4_h_fgsea_results <- fgsea(pathways = Mm.h, stats = ranks, minSize = 15, maxSize = 500)


#order genes for GEP5
scores_df <- scores_df[order(scores_df$GEP5, decreasing = TRUE), ]

#rank genes for GEP5 gsea
ranks <- scores_df$GEP5
names(ranks) <- scores_df$`Entrez ID`

GEP5_h_fgsea_results <- fgsea(pathways = Mm.h, stats = ranks, minSize = 15, maxSize = 500)



#dataframe of all NES scores for hallmark pathways
hallmark_df <- data.frame(GEP1_h_fgsea_results$NES, GEP2_h_fgsea_results$NES, GEP3_h_fgsea_results$NES, GEP4_h_fgsea_results$NES, GEP5_h_fgsea_results$NES, row.names = GEP1_h_fgsea_results$pathway)
colnames(hallmark_df) <- c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")

#remome HALLMARK_ from pathway names
pathway_names_altered <- list()
for (name in rownames(hallmark_df)) {
  name <- str_replace(name, "HALLMARK_", "")
  pathway_names_altered[[name]] <- name
}
rownames(hallmark_df) <- pathway_names_altered

#remove pathways to be excluded in heatmap
hallmark_df$test <- rownames(hallmark_df)
heatmap_pathways <- c("MYC_TARGETS_V1", "MYC_TARGETS_V2", "OXIDATIVE_PHOSPHORYLATION", "MTORC1_SIGNALING", "UNFOLDED_PROTEIN_RESPONSE", "GLYCOLYSIS", "FATTY_ACID_METABOLISM", "DNA_REPAIR", "UV_RESPONSE_UP", "UV_RESPONSE_DN", "XENOBIOTIC_METABOLISM", "P53_PATHWAY", "HYPOXIA", "IL2_STAT5_SIGNALING", "KRAS_SIGNALING_DN", "HEME_METABOLISM", "INTERFERON_GAMMA_RESPONSE", "ALLOGRAFT_REJECTION", "KRAS_SIGNALING_UP", "IL6_JAK_STAT3_SIGNALING", "INFLAMMATORY_RESPONSE", "TNFA_SIGNALING_VIA_NFKB", "COMPLEMENT", "APICAL_JUNCTION", "PROTEIN_SECRETION", "APICAL_SURFACE", "E2F_TARGETS", "G2M_CHECKPOINT", "MITOTIC_SPINDLE")

hallmark_df <- hallmark_df %>% filter(test %in% heatmap_pathways)
hallmark_df$test <- NULL

hallmark_ordered <- hallmark_df %>% arrange(match(rownames(hallmark_df), heatmap_pathways))
hallmark_ordered <- hallmark_ordered[,c(1,2,3,5,4)]

hallmark_test <- as.matrix(hallmark_ordered)




#Figure 6K
pheatmap(hallmark_test, cluster_cols = FALSE, cluster_rows = FALSE, scale = "row",  cellwidth = 10, cellheight = 10, fontsize_row = 8, color = colorRampPalette(c("blue4","cornsilk4","yellow2"))(50))

```


Working on Fig 6L now

##    GOBP pathway analysis
```{r include = TRUE, echo = TRUE}
#GOBP pathways downloaded from https://www.gsea-msigdb.org/gsea/msigdb/collections.jsp
#GMT file



Mm.c5_gobp <- gmtPathways(paste0(MSigDB_directory,"m5.go.bp.v2023.1.Mm.entrez.gmt"))

#order genes for GEP1
scores_df <- scores_df[order(scores_df$GEP1, decreasing = TRUE), ]

#rank genes for GEP1 gsea
ranks <- scores_df$GEP1
names(ranks) <- scores_df$`Entrez ID`

GEP1_gobp_fgsea_results <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000)


#order genes for GEP2
scores_df <- scores_df[order(scores_df$GEP2, decreasing = TRUE), ]

#rank genes for GEP2 gsea
ranks <- scores_df$GEP2
names(ranks) <- scores_df$`Entrez ID`

GEP2_gobp_fgsea_results <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000)


#order genes for GEP3
scores_df <- scores_df[order(scores_df$GEP3, decreasing = TRUE), ]

#rank genes for GEP3 gsea
ranks <- scores_df$GEP3
names(ranks) <- scores_df$`Entrez ID`

GEP3_gobp_fgsea_results <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000)


#order genes for GEP4
scores_df <- scores_df[order(scores_df$GEP4, decreasing = TRUE), ]

#rank genes for GEP4 gsea
ranks <- scores_df$GEP4
names(ranks) <- scores_df$`Entrez ID`

GEP4_gobp_fgsea_results <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000)


#order genes for GEP5
scores_df <- scores_df[order(scores_df$GEP5, decreasing = TRUE), ]

#rank genes for GEP1 gsea
ranks <- scores_df$GEP5
names(ranks) <- scores_df$`Entrez ID`

GEP5_gobp_fgsea_results <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000)


#dataframe of all NES scores for GOBP pathways
gobp_df <- data.frame(GEP1_gobp_fgsea_results$NES, GEP2_gobp_fgsea_results$NES, GEP3_gobp_fgsea_results$NES, GEP4_gobp_fgsea_results$NES, GEP5_gobp_fgsea_results$NES, row.names = GEP1_gobp_fgsea_results$pathway)
colnames(gobp_df) <- c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")


#remome GOBP_ from pathway names
pathway_names_altered <- list()
for (name in rownames(gobp_df)) {
  name <- str_replace(name, "GOBP_", "")
  pathway_names_altered[[name]] <- name
}
rownames(gobp_df) <- pathway_names_altered

temp_csv <- 
  read.csv("~/Sandbox/opa1-scRNAseq-local/Fig6L_pathways/opa1_wt_gsea_categorized.csv")

pathways_of_interest_df <- temp_csv[, c("category", "pathway")]
rm(temp_csv)

pathway_names_altered <- list()
for (name in pathways_of_interest_df$pathway) {
  name <- str_replace(name, "GOBP_", "")
  pathway_names_altered[[name]] <- name
}
pathways_of_interest_df$pathway <- names(pathway_names_altered)



row_index <- rownames(pathways_of_interest_df)
index <- 0
gobp_heatmap_pathways <- list()
for (pathway in pathways_of_interest_df$pathway) {
  gobp_heatmap_pathways[[pathway]] <- pathway
  index = index + 1
}

head(names(gobp_heatmap_pathways))

gobp_df$test <- rownames(gobp_df)
gobp_df_2 <- gobp_df %>% filter(test %in% names(gobp_heatmap_pathways))

#add category for pathway that will be used to group in figure
gobp_df_2$category <- pathways_of_interest_df$category[match(gobp_df_2$test, pathways_of_interest_df$pathway)]

#remove pathways with NA values
gobp_df_2 <- gobp_df_2[complete.cases(gobp_df_2), ]


gobp_df_2 <- gobp_df_2[order(gobp_df_2$category, decreasing = FALSE), ]

gobp_df_2$test <- NULL

gobp_df_ordered <- gobp_df_2[, c(1,2,3,5,4)]
gobp_matrix <- as.matrix(gobp_df_ordered)

pheatmap(gobp_df_ordered, cluster_cols = FALSE, cluster_rows = FALSE, scale = "row",  cellwidth = 7.5, cellheight = 7.5, fontsize_row = 6, fontsize_col = 6, color = colorRampPalette(c("blue4","cornsilk4","yellow1"))(25))




```

# 
```{r load pathways}

```

# 
```{r load pathways}


```



#   Attempt to get a list of GEP-associated genes and use that ranked list in GSEA

What the hell is this?


```{r include = TRUE, echo = TRUE}
get_top_colnames <- function(row) {
  # Orders the values in descending order and gets the names of the top 20
  print(row[1:5])
  top_indices <- order(row, decreasing = TRUE)[1:18533]
  return(colnames(spectra_score)[top_indices])
}
GEP_defining_genes <- apply(spectra_score, 1, get_top_colnames)
GEP_defining_genes <- as.data.frame(GEP_defining_genes)

GEP_defining_genes

colnames(GEP_defining_genes) <- c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")



#testing using the gep_defining genes


symbols <- GEP_defining_genes$GEP1
IDs <- mapIds(org.Mm.eg.db, symbols, 'ENTREZID', 'SYMBOL')

GEP_defining_genes <- as.data.frame(GEP_defining_genes)

GEP_defining_genes <- mutate(GEP_defining_genes, 'GEP1_Entrez ID' = IDs[GEP_defining_genes$GEP1])
GEP_defining_genes <- mutate(GEP_defining_genes, 'GEP2_Entrez ID' = IDs[GEP_defining_genes$GEP2])
GEP_defining_genes <- mutate(GEP_defining_genes, 'GEP3_Entrez ID' = IDs[GEP_defining_genes$GEP3])
GEP_defining_genes <- mutate(GEP_defining_genes, 'GEP4_Entrez ID' = IDs[GEP_defining_genes$GEP4])
GEP_defining_genes <- mutate(GEP_defining_genes, 'GEP5_Entrez ID' = IDs[GEP_defining_genes$GEP5])

GEP_defining_genes$ranks <- c(1:18533)

#GEP1
ranks <- GEP_defining_genes$rank
names(ranks) <- GEP_defining_genes$`GEP1_Entrez ID`
head(names(ranks))

GEP1_gobp_fgsea_results2 <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000, scoreType = 'pos')

#GEP2
ranks <- GEP_defining_genes$rank
names(ranks) <- GEP_defining_genes$`GEP2_Entrez ID`
head(names(ranks))

GEP2_gobp_fgsea_results2 <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000, scoreType = 'pos')

#GEP3
ranks <- GEP_defining_genes$rank
names(ranks) <- GEP_defining_genes$`GEP3_Entrez ID`
head(names(ranks))

GEP3_gobp_fgsea_results2 <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000, scoreType = 'pos')

#GEP4
ranks <- GEP_defining_genes$rank
names(ranks) <- GEP_defining_genes$`GEP4_Entrez ID`

GEP4_gobp_fgsea_results2 <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000, scoreType = 'pos')

#GEP5
ranks <- GEP_defining_genes$rank
names(ranks) <- GEP_defining_genes$`GEP5_Entrez ID`

GEP5_gobp_fgsea_results2 <- fgsea(pathways = Mm.c5_gobp, stats = ranks, minSize = 5, maxSize = 1000, scoreType = 'pos')


#dataframe of all NES scores for GOBP pathways
gobp_df <- data.frame(GEP1_gobp_fgsea_results2$NES, GEP2_gobp_fgsea_results2$NES, GEP3_gobp_fgsea_results2$NES, GEP4_gobp_fgsea_results2$NES, GEP5_gobp_fgsea_results2$NES, row.names = GEP1_gobp_fgsea_results2$pathway)
colnames(gobp_df) <- c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")


#remome GOBP_ from pathway names
pathway_names_altered <- list()
for (name in rownames(gobp_df)) {
  name <- str_replace(name, "GOBP_", "")
  pathway_names_altered[[name]] <- name
}
rownames(gobp_df) <- pathway_names_altered

temp_csv <- 
  read.csv("~/Documents/Sandbox/Opa1-scRNAseq/Fig6L_pathways/opa1_wt_gsea_categorized.csv")

pathways_of_interest_df <- temp_csv[, c("category", "pathway")]
rm(temp_csv)

pathway_names_altered <- list()
for (name in pathways_of_interest_df$pathway) {
  name <- str_replace(name, "GOBP_", "")
  pathway_names_altered[[name]] <- name
}
pathways_of_interest_df$pathway <- names(pathway_names_altered)



row_index <- rownames(pathways_of_interest_df)
index <- 0
gobp_heatmap_pathways <- list()
for (pathway in pathways_of_interest_df$pathway) {
  gobp_heatmap_pathways[[pathway]] <- pathway
  index = index + 1
}

head(names(gobp_heatmap_pathways))

gobp_df$test <- rownames(gobp_df)
gobp_df_2 <- gobp_df %>% filter(test %in% names(gobp_heatmap_pathways))

#add category for pathway that will be used to group in figure
gobp_df_2$category <- pathways_of_interest_df$category[match(gobp_df_2$test, pathways_of_interest_df$pathway)]

#remove pathways with NA values
gobp_df_2 <- gobp_df_2[complete.cases(gobp_df_2), ]


gobp_df_2 <- gobp_df_2[order(gobp_df_2$category, decreasing = FALSE), ]

gobp_df_2$test <- NULL

gobp_df_ordered <- gobp_df_2[, c(1,2,3,5,4)]
gobp_matrix <- as.matrix(gobp_df_ordered)

pheatmap(gobp_df_ordered, cluster_cols = FALSE, cluster_rows = FALSE, scale = "row",  cellwidth = 7.5, cellheight = 7.5, fontsize_row = 6, fontsize_col = 6, color = colorRampPalette(c("blue4","cornsilk4","yellow1"))(25))



```









--------------------
current work above!















make sense of old code

# 
```{r include = TRUE, echo = TRUE}
Opa1KO_markers <- FindMarkers(Tcell_data_object, ident.1 = "d5_opa1_unique", ident.2 = "d5_dividing")

#convert gene symbols to the coresponding entrez ID
symbols <- rownames(Opa1KO_markers)
IDs <- mapIds(org.Mm.eg.db, symbols, 'ENTREZID', 'SYMBOL')
Opa1KO_markers <- mutate(Opa1KO_markers, 'Entrez ID' = IDs[rownames(Opa1KO_markers)])
#remove genes with no Entrez ID

#indicate statistic to use for gsea analysis
ranks <- Opa1KO_markers$avg_log2FC
names(ranks) <- Opa1KO_markers$'Entrez ID'
head(ranks)

#indicate statistic to use for gsea analysis
#ranks_p <- Opa1KO_markers$p_val_adj
#names(ranks_p) <- Opa1KO_markers$'Entrez ID'
#head(ranks_p)


Opa1KO_h_fgsea_results <- fgsea(pathways = Mm.h, stats = ranks, minSize = 15, maxSize = 500)

```


















Load the relevant pathaways from msigdbr(these are the same pathways but just a different format for use with this package). C5 is gene ontology pathways so it could be of interest for you
```{r enricher pathways}

install.packages("msigdbr")
library(msigdbr)
Mm.H.df<- msigdbr(species = "Mus musculus", category = "H") %>% dplyr::select(gs_name, gene_symbol)
Mm.C2.df <-msigdbr(species = "Mus musculus", category = "C2") %>% dplyr::select(gs_name, gene_symbol)
Mm.C5.df <-msigdbr(species = "Mus musculus", category = "C5") %>% dplyr::select(gs_name, gene_symbol)
Mm.C7.df <-msigdbr(species = "Mus musculus", category = "C7") %>% dplyr::select(gs_name, gene_symbol)
```


# 
```{r include = TRUE, echo = TRUE}
test = GEP_defining_genes
symbols <- GEP_defining_genes$GEP1
IDs <- mapIds(org.Mm.eg.db, symbols, 'ENTREZID', 'SYMBOL')
IDs

test$GEP1 <- IDs
test2 <- test$GEP4



outputH <- enricher(gene = test2, TERM2GENE = Mm.H.df)
dotplot(outputH, showCategory=10, x="GeneRatio", color="p.adjust", title="MCJ KD vs WT - Hallmark Enrichment")


Opa1KO_markers <- mutate(Opa1KO_markers, 'Entrez ID' = IDs[rownames(Opa1KO_markers)])
```



# 
```{r include = TRUE, echo = TRUE}
test_gsea <- fgsea(pathways = Mm.h,
                   stats = as.list(test$GEP1),
                   scoreType = "std",
                   minSize = 1,
                   maxSize = 500,
                   nproc = 1)

test_gsea <- enrichGSEA(test$GEP4,
                        TERM2GENE = )
```










#   Get table of Entrez_ID in one column and spectrum score for most influencial (top 100 genes)
    in second column
```{r include = TRUE, echo = TRUE}
#GEP1 first
GEP1_list <- list()
for (gene in GEP1_genes) {
  print(gene)
  print(spectra_score[[gene]])
  print(spectra_score[[gene]][1])
  GEP1_list[[gene]] <- spectra_score[[gene]][1]
}

GEP1_df <- data.frame(GEP1_list)
GEP1_df <- t(GEP1_df)
colnames(GEP1_df) <- "GEP1"

#Turn GEP1_df into data frame
class(GEP1_df)
GEP1_df <- data.frame(GEP1_df)

#convert gene symbols to the coresponding entrez ID
symbols <- rownames(GEP1_df)
IDs <- mapIds(org.Mm.eg.db, symbols, 'ENTREZID', 'SYMBOL')
GEP1_df <- mutate(GEP1_df, 'Entrez ID' = IDs[rownames(GEP1_df)])

#indicate statistic to use for gsea analysis
ranks <- GEP1_df$GEP1
names(ranks) <- GEP1_df$'Entrez ID'
head(ranks)

#shit. some progress being made but this is empty...
GEP1_h_fgsea_results <- fgsea(pathways = Mm.h, stats = ranks, minSize = 5, maxSize = 500)

GEP1_c2_fgsea_results <- fgsea(pathways = Mm.c2, stats = ranks, minSize = 5, maxSize = 500)



















#not sure if I need this anymore

get_top_colnames <- function(row) {
  top_indices <- order(row, decreasing = TRUE)[1:5]
  print(top_indices)
  return(colnames(spectra_score)[top_indices])
}

test_scores <- apply(spectra_score,1, get_top_scores)

test_genes <- apply(spectra_score, 1, get_top_colnames)
test_genes_df <- as.data.frame(test_genes)



#1




#failed attempts
GEP1_genes
spectra_score$Ccnd3[1]
spectra_transpose <- as.data.frame(t(spectra_score))
spectra_transpose$gene <- rownames(spectra_transpose)

spectra_test <- as.data.frame(spectra_score)

GEP1_scores <- spectra_score %>% filter(rownames(spectra_transpose) %in% GEP1_genes)

y <- subset(spectra_score, colnames(spectra_score) %in% GEP1_genes, rownames(spectra_score) %in% GEP1_genes)

```


# 
```{r include = TRUE, echo = TRUE}

```

# 
```{r include = TRUE, echo = TRUE}

```



---
title: "BW2310 Opa1 scRNAseq d5"
author: "Ben Willett"
date: "250217"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
---


##    Notes:
- Regress out cell cycle at the beggining
- Cluster and remove contaminates
- Split naive and activated CD8s. Label in metadata
- Recombine objects so I can show violin plots for naive and activated cells
- I needed to redo the FindVariableFeatures(), scaling, etc. after I added the 'naive' and 'activated' labels to my cells
  
#     Install/Load packages (STEP 0)
This section is always required.  You will load all packages necessary for the scope of the assignment in between the code blocks.  

```{r, include =TRUE, echo=TRUE, message = FALSE}
# load packages here
library(SingleCellExperiment) #done
library(Seurat) #done
library(tidyverse) #done
library(Matrix) #done
library(scales) #done
library(cowplot) #done
library(RCurl) #done
library(AnnotationHub) #done
library(AnnotationFilter) #done
library(AnnotationDbi) #done
library(ensembldb) #done
library(SeuratWrappers) #done
library(harmony) #done
library(ggpubr) #done
library(gridExtra) #done
library(metap) #done
library(VISION) #done
library(clusterProfiler) #done
library(ggsci) #done
#library(lisi) #no but I don't think I need it
library(MetBrewer) #done
library(wesanderson) #done
library(scDblFinder) #done

#stacking vln plots
library(scCustomize)

#for later pathway analysis (taken from SBT's code)
#library(readxl)
library(org.Mm.eg.db)
library(patchwork)
library(writexl)
library(fgsea)

#cNMF
library(readr)
library(dplyr)

#gsea heatmaps
library(RColorBrewer)
library(pheatmap)

```

#     Read in Data 

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
#path to 10X data
opa1_directory <- "~/Sandbox/opa1-scRNAseq-local/10X_data/opa1/10X_files"
wt_directory <-"~/Sandbox/opa1-scRNAseq-local/10X_data/wt/10X_files"

opa1 <- Read10X(data.dir = opa1_directory, unique.features = TRUE, strip.suffix = TRUE)
wt <- Read10X(data.dir = wt_directory, unique.features = TRUE, strip.suffix = TRUE)
```

#     Generate Seurat Objects
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
sample_1 <- "wt"
sample_2 <- "opa1"


wt_obj <- CreateSeuratObject(counts = wt, project = sample_1)
opa1_obj <- CreateSeuratObject(counts = opa1, project = sample_2)

rm(sample_1, sample_2)

```

##     Check metadata  
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}

head(wt_obj@meta.data)
tail(wt_obj@meta.data)

head(opa1_obj@meta.data)
tail(opa1_obj@meta.data)

dim(wt_obj@meta.data) #7500 cells in WT sample
dim(opa1_obj@meta.data) #6700 cells in Opa1 sample

#confirm row names = gene names
row.names(wt_obj@assays$RNA)
row.names(opa1_obj@assays$RNA) 

#confirm col names = cell barcodes
colnames(wt_obj@assays$RNA) 
colnames(opa1_obj@assays$RNA)

```

      Total reads across cells

```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
sum(wt_obj@meta.data$nCount_RNA)
sum(opa1_obj@meta.data$nCount_RNA)
```

#     Add sample specific metadata
##    Add genotype id 
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
#INPUT NEEDED
metadata_to_add <- "genotype"
sample_1 <- "wt"
sample_2 <- "opa1"

wt_obj <- AddMetaData(wt_obj, metadata = sample_1, col.name = metadata_to_add)
opa1_obj <- AddMetaData(opa1_obj, metadata = sample_2, col.name = metadata_to_add)

rm(metadata_to_add, sample_1, sample_2)
```

#     Merge Data
```{r include=TRUE, echo=TRUE, warning = FALSE, message = FALSE}
#INPUT NEEDED
sample_list <- c("wt", "opa1")

#Merge data
merged_data_object <- merge(x = wt_obj,
                            y = opa1_obj,
                            add.cell.id = sample_list)

merged_data_object <- JoinLayers(merged_data_object)

#confirm merging
head(merged_data_object@meta.data)
tail(merged_data_object@meta.data)

#confirm same cell numbers from individual wt/opa1 seurat objects
table(merged_data_object@meta.data$orig.ident)


rm(sample_list)
gc()
```

#     Managing memory and space - post merge
```{r include=TRUE, echo=TRUE}
rm(wt, wt_obj, opa1, opa1_obj, wt_directory, opa1_directory)
gc()
```

#     Data Setup and Formatting 
## Calculating per cell complexity, add to metadata 
```{r include = TRUE, echo = TRUE}
#INPUT NEEDED
metadata_to_add <- "complexity"

#Add cell complexity
merged_data_object <- AddMetaData(object = merged_data_object,
                                  metadata = log10(merged_data_object$nFeature_RNA)/log10(merged_data_object$nCount_RNA),
                                  col.name = metadata_to_add)

rm(metadata_to_add)
gc()
```

## Calculating mitochondrial read percentage per cell and adding this to the metadata  
```{r include = TRUE, echo = TRUE}
#INPUT NEEDED
mito_identifier <- "mt-"


#"mt-" is the identifier for mitochondrial genes in this set
grep(rownames(merged_data_object@assays$RNA),
     pattern = mito_identifier,
     value = TRUE)


#Adding mitoPct to the metadata 
merged_data_object$mitoPct <- PercentageFeatureSet(object = merged_data_object,
                                                   pattern = mito_identifier)

rm(mito_identifier)
gc()

```

#     Initial Data Exploration 
##    Total Cells per Sample  
```{r include = TRUE, echo = TRUE}
#INPUT REQUIRED
dataset <- merged_data_object@meta.data
graphing_var <- "orig.ident"
graph_title <- "Number of Cells Per Sample (raw)"

#Bar graph:
ggplot(dataset,
       aes(x=!!rlang::sym(graphing_var),
           fill=!!rlang::sym(graphing_var))) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle(graph_title)


rm(dataset, graphing_var, graph_title)
gc()
```

##    Distribution of total number of reads per cell  
```{r include = TRUE, echo = TRUE}
#INPUT NEEDED
dataset <- merged_data_object@meta.data
x_var <- "nCount_RNA"
plot_var <- "genotype"
y_label <- "Cell density"
plot_title <- "Distribution of reads per cell across samples"

plot_density <- 0.25

#density plot
ggplot(dataset,
       aes(color=!!rlang::sym(plot_var),
           x=!!rlang::sym(x_var),
           fill=!!rlang::sym(plot_var))) +
geom_density(alpha = plot_density) +
scale_x_log10() +
theme_classic() +
ylab(y_label) +
ggtitle(plot_title)

rm(dataset, x_var, plot_var, y_label, plot_title, plot_density)
gc()

```

##    Distribution of total number of unique genes expressed per cell  
```{r include = TRUE, echo = TRUE}
#INPUT REQUIRED
dataset <- merged_data_object@meta.data
groups <- "genotype"
plotting_var <- "nFeature_RNA"
title <- "Distribution of total unique genes per cell across samples"

plot_density <- 0.25


#density plot

ggplot(dataset,
       aes(color=!!rlang::sym(groups),
           x=!!rlang::sym(plotting_var),
           fill= !!rlang::sym(groups))) +
 geom_density(alpha = plot_density) +
 theme_classic() +
 scale_x_log10() +
ggtitle(title)

#Boxplot

ggplot(dataset,
       aes(x=!!rlang::sym(groups),
           y=log10(!!rlang::sym(plotting_var)),
           fill=!!rlang::sym(groups))) +
geom_boxplot() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold")) +
ggtitle(title)

rm(dataset, groups, plotting_var, title, plot_density)
gc()

```

##    Joint plot of reads, genes, and mitochondrial percentage  
```{r include = TRUE, echo = FALSE, message = FALSE, warning=FALSE}

#INPUT REQUIRED
dataset <- merged_data_object@meta.data
x_var <- "nCount_RNA"
y_var <- "nFeature_RNA"
shading_var <- "mitoPct"

color_scale_low <-"gray90"
color_scale_hi <- "black"

facet_wrap_var <- "genotype"

#Joint Plot:
ggplot(dataset,
       aes(x=!!rlang::sym(x_var),
           y=!!rlang::sym(y_var),
           color=!!rlang::sym(shading_var))) +
   geom_point() +
   scale_colour_gradient(low = color_scale_low,
                         high = color_scale_hi) +
   stat_smooth(method=lm) +
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(vars({{facet_wrap_var}}))

rm(dataset, x_var, y_var, shading_var, color_scale_low, color_scale_hi, facet_wrap_var)
gc()

```


##    Distribution of mitochondrial percent per cell  

      #Expected that the Opa1ko have even less mito chontamination than wt because the MITOCHONDRIAL GENOME IS        NOT MAINTAINED in Opa1ko cells!!
```{r include=TRUE, echo=TRUE, warning = FALSE}
#INPUT REQUIRED
dataset <- merged_data_object@meta.data
groups <- "genotype"
x_var <- "mitoPct"

plot_density <- 0.25
title <- "Distribution of mitochondrial contamination per cell across samples"

#Density plot

ggplot(merged_data_object@meta.data,
       aes(color=!!rlang::sym(groups),
           x=!!rlang::sym(x_var),
           fill=!!rlang::sym(groups))) +
geom_density(alpha = plot_density) +
scale_x_log10() +
theme_classic()+
ggtitle(title)

rm(dataset, groups, x_var, plot_density, title)
gc()

```

##    Distribution of library complexity per cell
```{r include=TRUE, echo=TRUE}
#INPUT REQUIRED
dataset <- merged_data_object@meta.data
groups <- "genotype"
x_var <- "complexity"

#density plot - cellular complexity

plot_density <- 0.25
title <- "Distribution of complexity across samples"

ggplot(dataset, aes(x=!!rlang::sym(x_var),
                    color = !!rlang::sym(groups),
                    fill=!!rlang::sym(groups))) +
        geom_density(alpha = plot_density) +
        theme_classic() + 
  ggtitle(title)

rm(dataset, groups, x_var, plot_density, title)
gc()

```

##    Other plots  
      violin plots of prev data
```{r include=TRUE, echo=TRUE}
#INPUT NEEDED
features_to_plot <- c("nFeature_RNA", "nCount_RNA", "mitoPct")

#Violin plots
VlnPlot(merged_data_object,
        features = features_to_plot,
        ncol = 3)
VlnPlot(merged_data_object,
        features = features_to_plot,
        stack = T)

rm(features_to_plot)
gc()

```

#     Filtering 
##    Cell-Level filtering

* keep cells with at least 200 unique genes present per cell  
* keep cells with at 1000 reads present per cell  
* keep cells that have a mitochondrial contamination percent of less than 20%  
* keep cell with a complexity of greater than 80%  


```{r include = TRUE, echo = TRUE}
#INPUT NEEDED
gene_filter <- 200
read_filter <- 1000
mito_filter <- 10
complexity_filter <- 0.75

#Create filtered data object
#based on prior distributions/graphs of various features

filtered_data_object <- subset(x = merged_data_object,
                               subset = 
                                 (nFeature_RNA >= gene_filter) &
                                 (nCount_RNA >= read_filter) &
                                 (mitoPct < mito_filter) &
                                 (complexity > complexity_filter))

rm(gene_filter, read_filter, mito_filter, complexity_filter)
gc()

```

* The total number of cells before filtering  
* The total number of cell after filtering  

```{r include = TRUE, echo = TRUE}

paste("The number of cells prior to filtering:")
dim(merged_data_object@meta.data)[1]

paste("The number of cells after filtering:")
dim(filtered_data_object@meta.data)[1]

```

##    Gene-Level filtering  

Remove the following genes:
* that have 0 counts across all cells  
* not present in at least 10 cells  

```{r include = TRUE, echo = TRUE}
#INPUT NEEDED
dataset <- filtered_data_object
seurat_assay <- "RNA"
seurat_layer <- "counts"

#filtering
counts <- LayerData(dataset,
                    assay = seurat_assay,
                    layer = seurat_layer)

nonzero <- counts > 0
nonzero

#filter out everything with less than 10 reads across all cells
less_10 <- Matrix::rowSums(nonzero) >= 10
less_10_matrix <- counts[less_10,]

#Using 10 as cutoff
keep_genes <- Matrix::rowSums(nonzero) >= 10
filtered_counts <- counts[keep_genes, ]
head(filtered_counts)

#32285 genes prior to filtering
dim(dataset@assays$RNA@features)

#13752 genes have been removed via this filtering
#less_10_matrix is the genes that remain after filtering. so ~18k genes remain after filtering
print(dim(dataset@assays$RNA@features)[1] - dim(less_10_matrix)[1])


dataset <- CreateSeuratObject(counts = filtered_counts,
                                           meta.data = dataset@meta.data)


rm(dataset, seurat_assay, seurat_layer, nonzero, keep_genes, counts, filtered_counts, less_10_matrix, less_10)
gc()

```


#     Post-Filtering Data Examination 
##    Total Cells per Sample  
```{r include = TRUE, echo = TRUE}
#INPUT NEEDED
dataset <- filtered_data_object@meta.data
groups <- "genotype"

ggplot(dataset, aes(color=!!rlang::sym(groups),
                    x=!!rlang::sym(groups),
                    fill=!!rlang::sym(groups))) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

rm(dataset, groups)
```
 
##    Distribution of total number of reads per cell  

```{r include = TRUE, echo = TRUE}
#INPUT NEEDED
dataset <- filtered_data_object@meta.data
groups <- "genotype"
x_var <- "nCount_RNA"

plot_density <- 0.25
y_label <- "cell density"

#filter line vars
x_int <- 1000
line_type <- "dashed"
line_color <- "orange"
line_width <- 2

ggplot(dataset, aes(color=!!rlang::sym(groups),
                    x=!!rlang::sym(x_var),
                    fill= !!rlang::sym(groups))) +
  geom_density(alpha = plot_density) +
  scale_x_log10() +
  theme_classic() +
  ylab(y_label) +
  geom_vline(xintercept = x_int,
             linetype = line_type,
             color = line_color,
             linewidth = line_width)

rm(dataset, groups, x_var, plot_density, y_label, x_int, line_type, line_color, line_width)
gc()

```

##    Distribution of total number of unique genes expressed per cell  

```{r include = TRUE, echo = TRUE, warning=FALSE}
#INPUT NEEDED
dataset <- filtered_data_object@meta.data
groups <- "genotype"
x_var <- "nFeature_RNA"

plot_density <- 0.25
title <- "cell density"


ggplot(dataset,
       aes(color=!!rlang::sym(groups),
           x=!!rlang::sym(x_var),
           fill= !!rlang::sym(groups))) +
  geom_density(alpha = plot_density) +
  scale_x_log10() +
  theme_classic() +
  ylab(title)

rm(dataset, groups, x_var, plot_density, title)
gc()

```

##    Joint plot of reads, genes, and mitochondrial percentage  

```{r include = TRUE, echo = TRUE, warning=FALSE, message=FALSE}
#INPUT REQUIRED
dataset <- filtered_data_object@meta.data
x_var <- "nCount_RNA"
y_var <- "nFeature_RNA"
shading_var <- "mitoPct"

color_scale_low <-"gray90"
color_scale_hi <- "black"

facet_wrap_var <- "genotype"

#Joint Plot:
ggplot(dataset,
       aes(x=!!rlang::sym(x_var),
           y=!!rlang::sym(y_var),
           color=!!rlang::sym(shading_var))) +
   geom_point() +
   scale_colour_gradient(low = color_scale_low, high = color_scale_hi) +
   stat_smooth(method=lm) + #throws in linear model line (blue line)
   scale_x_log10() +
   scale_y_log10() +
   theme_classic() +
   facet_wrap(vars({{facet_wrap_var}}))

rm(dataset, x_var, y_var, shading_var, color_scale_low, color_scale_hi, facet_wrap_var)
gc()

```

##    Distribution of mitochondrial percent per cell  

```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
#INPUT NEEDED
dataset <- filtered_data_object@meta.data
groups <- "genotype"
x_var <- "mitoPct"

plot_density <- 0.25
y_label <- "cell density"

#filter line vars
x_int <- 20
line_type <- "dashed"
line_color <- "orange"
line_width <- 2


ggplot(dataset,
       aes(color=!!rlang::sym(groups),
           x=!!rlang::sym(x_var),
           fill=!!rlang::sym(groups))) +
geom_density(alpha = plot_density) +
scale_x_log10() +
theme_classic() +
geom_vline(xintercept = x_int,
           linetype = line_type,
           color = line_color,
           linewidth = line_width)

rm(dataset, groups, x_var, plot_density, y_label, x_int, line_type, line_color, line_width)
gc()

```

##    Distribution of library complexity per cell  

```{r include=TRUE, echo=TRUE}
#INPUT NEEDED
dataset <- filtered_data_object@meta.data
x_var <- "complexity"
groups <- "genotype"

plot_density <- 0.25

#density plot - complexity
ggplot(filtered_data_object@meta.data,
       aes(x=!!rlang::sym(x_var),
           color=!!rlang::sym(groups),
           fill=!!rlang::sym(groups))) +
        geom_density(alpha = plot_density) +
theme_classic()

rm(dataset, x_var, groups, plot_density)
gc()

```

##    Other plots  
      Violin plots
        - reads
        - genes
        - mitoPct
        
```{r include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
features_to_plot <- c("nCount_RNA", "nFeature_RNA", "mitoPct")

VlnPlot(filtered_data_object, features = features_to_plot, stack = T)

rm(features_to_plot)
```


#     Normalization and gene score calculations   
      Now that we have visually identified some cell-level thresholds  

##    Gene expression normalization  

```{r include = TRUE, echo = TRUE}
#USER INPUT
dataset <- filtered_data_object
norm.method <- "LogNormalize"
assay <- "RNA"

#normalization
filtered_data_object <- NormalizeData(object = dataset,
                                      normalization.method = norm.method,
                                      assay = assay)



#sanity check. All are floats/continuous values. The raw data is integers
filtered_data_object@assays$RNA@layers

rm(dataset, norm.method, assay)
gc()

```

## Calculate cell cycling scores    

```{r include = TRUE, echo = TRUE}
#USER INPUT
dataset <- filtered_data_object

g2m_genes <- cc.genes.updated.2019$g2m.genes
s_genes <- cc.genes.updated.2019$s.genes

#Scoring cell cycle phase
dataset <- CellCycleScoring(object = dataset,
                                         g2m.features = g2m_genes,
                                         s.features = s_genes)

filtered_data_object <- dataset

rm(dataset, g2m_genes, s_genes)
gc()

```

##   Distribution of cells per phase

```{r include = TRUE, echo = TRUE}
dataset <- filtered_data_object@meta.data
var1 <- "Phase"
var2 <- "genotype"

#X is phase
ggplot(dataset,
       aes(x=!!rlang::sym(var1),
           fill=!!rlang::sym(var2))) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

#X is genotype
ggplot(dataset,
       aes(x=!!rlang::sym(var2),
           fill=!!rlang::sym(var1))) +
geom_bar() +
theme_classic() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(plot.title = element_text(hjust=0.5, face="bold"))

rm(dataset, var1, var2)
gc()

```  

#     PCA 

##    Identify most variable genes  
      Use standard 2000 most variable genes:

```{r include = TRUE, echo=TRUE}
dataset <- filtered_data_object
sel.method <- "vst"
num.genes <- 2000
assay <- "RNA"
vG_rownames <- "Gene"


filtered_data_object <- FindVariableFeatures(object = dataset,
                                             selection.method = sel.method,
                                             nfeatures = num.genes,
                                             verbose = FALSE,
                                             assay = assay)

VariableFeatures(object = dataset,
                 method = sel.method,
                 assay = assay)

#check that these genes are ok to be used for clustering
variableGeneDf <- as_tibble(HVFInfo(dataset,
                                    selection.method = sel.method,
                                    status = TRUE,
                                    assay = assay),
                                    rownames = vG_rownames)

variableGeneDf = variableGeneDf %>%
  mutate(hypervariable=Gene %in%
           VariableFeatures(dataset,
                            selection.method = sel.method,
                            assay = assay))

#plot
ggplot(variableGeneDf, aes(x = log(mean),
                       y = log(variance),
                       color = hypervariable)) +
                       geom_point()

#USER INPUT - update seurat object
filtered_data_object <- dataset

rm(sel.method, num.genes, assay, variableGeneDf, dataset, vG_rownames)
gc()

```

##    Scale the data 
      Regress out cell cycle

```{r include = TRUE, echo = TRUE}
#USER INPUT
dataset <- filtered_data_object
assay <- "RNA"
regress_variables <- "Phase"


dataset <- ScaleData(object = dataset,
                                  assay = assay,
                                  vars.to.regress = regress_variables)


#USER INPUT - update seurat object
filtered_data_object <- dataset

rm(dataset, assay, regress_variables)
gc()

```

##    Calculate principle components 

```{r include = TRUE, echo = TRUE}
#USER INPUT NEEDED
dataset <- filtered_data_object
assay <- "RNA"
seed <- 18
pcs_to_run <- 50


dataset <- RunPCA(object = dataset,
                               assay = assay,
                               seed.use = seed,
                               npcs = pcs_to_run,
                               weight.by.var = TRUE)

#USER INPUT - update seurat object
filtered_data_object <- dataset

rm(dataset, assay, seed, pcs_to_run)

```

##    Visualizing of principle components  
###   Dim Plots
      * Phase  
      * stimulation_status  
      * orig.ident  

```{r include=TRUE, echo=TRUE}

dataset <- filtered_data_object
reduction <- "pca"
grouping <- list("Phase", NULL, "orig.ident", "Phase")
splitting <- list(NULL, "Phase", NULL, "orig.ident")

plot_list <- list()
i <- 1
for (pca_index in 1:4) {
  plot <- DimPlot(object = dataset,
                  reduction = reduction,
                  group.by = grouping[[pca_index]],
                  split.by = splitting[[pca_index]],
                  order = TRUE)
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

rm(dataset, reduction, grouping, splitting, plot_list, i, pca_index, plot)
gc()

```

###   FeaturePlot and heatmap

      *  mitchondrial percentage
      *  heatmap of PCs and the top genes defining them

```{r include=TRUE, echo=TRUE}
#USER INPUT NEEDED
dataset <- filtered_data_object
reduction <- "pca"
# for feature plot
plot_feature <- "mitoPct"
splitting.by <- "genotype"

# for heatmap
dims <- 1:9
cells <- 500
assay <- "RNA"

FeaturePlot(object = dataset,
            reduction = reduction,
            features = plot_feature,
            split.by = splitting.by,
            order = TRUE)

DimHeatmap(object = dataset,
           dims = dims,
           cells = cells,
           balanced = TRUE,
           assays = assay,
           reduction = reduction
           )

rm(dataset, reduction, plot_feature, splitting.by, dims, cells, assay )
gc()

```

###   Elbow Plot  

    Decide how many PCs to use.
    Using 20

```{r include = TRUE, echo = TRUE}
#USER INPUT NEEDED
dataset <- filtered_data_object
dims <- 50
reduction <- "pca"


ElbowPlot(object = dataset,
          ndims = dims,
          reduction = reduction)

#USER INPUT NEEDED - how many PCs to use moving forward
pcs = 20

rm(dataset, dims, reduction)

```

###   *t*-SNE  

```{r include = TRUE, echo = TRUE}
#USER INPUT NEEDED
dataset <- filtered_data_object
reduction <- "pca"
assay <- "RNA"
seed <- 18
ReductionName <- "initial_tsne"

#dimensions for plotting
dimensions <- 1:2

#how you want the resulting tsne plots to be grouped by:
grouping <- c("orig.ident", "Phase")


dataset <- RunTSNE(object = dataset,
                                dims = 1:pcs,
                                reduction = reduction,
                                assay = assay,
                                seed.use = seed,
                                reduction.name = ReductionName)



DimPlot(object = dataset,
        dims = dimensions,
        reduction = ReductionName,
        group.by = grouping[[1]])

DimPlot(object = dataset,
        dims = dimensions,
        reduction = ReductionName,
        group.by = grouping[[2]])

filtered_data_object <- dataset

rm(dataset, reduction, assay, seed, ReductionName, dimensions, grouping)
gc()

```

### UMAP  

```{r include = TRUE, echo = TRUE}
#USER INPUT NEEDED
dataset <- filtered_data_object
reduction <- "pca"
assay <- "RNA"
seed <- 18
ReductionName <- "initial_umap"

#dimensions for plotting
dimensions <- 1:2

dataset <- RunUMAP(object = dataset,
                                dims = 1:pcs,
                                reduction = reduction,
                                assay = assay,
                                n.neighbors = 30,
                                seed.use = seed,
                                reduction.name = ReductionName)


#update seurat object
filtered_data_object <- dataset



##### cleanup #####
rm(dataset, reduction, assay, seed, ReductionName, dimensions)
gc()

```

####    UMAP plots

```{r include=TRUE, echo=TRUE}
#USER INPUT NEEDED
dataset <- filtered_data_object
reduction <- "pca"
assay <- "RNA"
seed <- 18
ReductionName <- "initial_umap"

#dimensions for plotting
dimensions <- 1:2

grouping <- list("genotype", "Phase", "Phase")
splitting <- list(NULL, NULL, "genotype")

plot_list <- list()
i <- 1
for (pca_index in 1:3) {
  plot <- DimPlot(object = dataset,
                  reduction = ReductionName,
                  group.by = grouping[[pca_index]],
                  split.by = splitting[[pca_index]],
                  order = TRUE)
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}


##### cleanup #####
rm(dataset, reduction, assay, seed, ReductionName, dimensions, grouping, splitting, plot_list, i, plot, pca_index)
gc()

```


#     Clustering 

##    Find cell neighbors
      --> Uses pcs variable defined earlier

```{r include=TRUE, echo=TRUE}
#USER INPUT NEEDED
reduction <- "pca"
assay <- "RNA"


filtered_data_object <- FindNeighbors(object = filtered_data_object,
                                      reduction = reduction,
                                      dims = 1:pcs,
                                      assay = assay)

```

##      Select clustering resolution to test  
###         Testing resolutions:
            0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.6, 1.0, 1.4
            
```{r include = TRUE, echo = TRUE}

#USER INPUT NEEDED
#finding clusters
dataset <- filtered_data_object
resolutions_to_test <- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.6, 1.0, 1.4)
seed <- 18
algo_num <-1

#plotting cluster resolutions on umap
reduction <- "initial_umap"
splitting.by <- "genotype"




dataset <- FindClusters(object = dataset,
                        resolution = resolutions_to_test,
                        algorithm = algo_num,
                        random.seed = seed)

plot_list <- list()
i <-1 
for (res in resolutions_to_test) {
  plot <-   DimPlot(object = dataset,
              reduction = reduction,
              label = FALSE,
              label.size = 6,
              group.by = paste0("RNA_snn_res.", res),
              split.by = splitting.by) +
              ggtitle(paste0("Res = ", res))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

#NOT deleting dataset variable yet, will do so at the end of the next batch of code

```
###         Resolution picked: 0.15
            10 clusters

```{r include = TRUE, echo = TRUE}
#USER INPUT NEEDED
final_resolution <- "0.15"


#update temporary seurat object (dataset)
Idents(object = dataset) <- "RNA_snn_res.0.15"
dataset$seurat_clusters <- dataset@active.ident

#delete old resolutions
metadata_to_delete <- list("RNA_snn_res.0.05", 
                           "RNA_snn_res.0.1",
                           "RNA_snn_res.0.2",
                           "RNA_snn_res.0.25",
                           "RNA_snn_res.0.3",
                           "RNA_snn_res.0.4",
                           "RNA_snn_res.0.6",
                           "RNA_snn_res.1",
                           "RNA_snn_res.1.0",
                           "RNA_snn_res.1.4")
for (metadata in metadata_to_delete) {
  data_cat <- paste0("dataset$", metadata, " <- NULL")
  eval(rlang::parse_expr(data_cat))
}

#update filtered_data_object
filtered_data_object <- dataset

rm(grouping, plot_list, plot, i, res, final_resolution, resolutions_to_test, resolution_plots, metadata_to_delete, metadata, data_cat, seed, algo_num, assay, splitting.by)
gc()
```
###         Double check filtered_data_object by a few other splits/groupings
            Resolution 0.15 looks good.

```{r include = TRUE, echo = TRUE}
reduction <- "initial_umap"
final_resolution <- "0.15"
resolution_check <- "RNA_snn_res.0.15"

#double check. Looks good.
resolution_plots <- list(NULL, "orig.ident", "Phase")
plot_list <- list()
i <- 1
for (grouping in resolution_plots) {
  plot <-   DimPlot(object = filtered_data_object,
              reduction = reduction,
              label = FALSE,
              label.size = 6,
              group.by = paste0(resolution_check),
              split.by = grouping) +
              ggtitle(paste0("Resolution = ", final_resolution, " (Resolution chosen)"))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}


rm(dataset, plot, plot_list, grouping, final_resolution, reduction, resolution_check, i, resolution_plots)
gc()

``` 

#      Save/Load filtered data object
        pca, tsne, umap reductions have been done
        Clustering and analysis are next
```{r include = TRUE, echo = TRUE}
seurat_directory <- "~/Sandbox/opa1-scRNAseq-local/seurat_objects/"
filtered_object <- "filtered_data_object_postclustering.RDS"


##### Save point #####
saveRDS(object = filtered_data_object, paste0(seurat_directory, filtered_object))

##### Load if needbe #####
#filtered_data_object <- readRDS(paste0(seurat_directory, filtered_object))

##### cleanup #####
# no longer need merged data object

rm(filtered_object, merged_data_object)
gc()
```


#     Covariate check of clusters     

##      Feature plots

          * nCount_RNA  (reads)
          * nFeature_RNA  (genes)
          * mitoPct  (percent mito genes)

```{r include = TRUE, echo = TRUE}
#USER INPUT NEEDED
covariate_checks <- list("nCount_RNA", "nFeature_RNA", "mitoPct")
reduction <- "initial_umap"
groups <- "genotype"
plot_list <- list()
i <- 1


for (covariate in covariate_checks) {
  plot <-   FeaturePlot(object = filtered_data_object,
              reduction = reduction,
              features = covariate,
              split.by = groups,
              order = TRUE) + theme(legend.position = c(0.8,0.9))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

rm(covariate_checks, covariate, plot_list, i, reduction, groups)
gc()

``` 

## IDing clusters based on commonly expressed genes

  cluster 5 = NK cells/ILC1s (Ncr1, Il12rb2, Itga1)
  cluster 6 = RBCs (Hba-a1 = hemoglobin)
  cluster 7,9 = Macrophages/B cells (H2-Ab1 = MHC class II), Spi1 is a B cell/Myeloid dev marker
  cluster 8 = CD163l1 -> some sort of fetal-derived CD8s
  
  Based on above and CD8 and CD3e expression, clusters 0-4 are what I want

```{r include = TRUE, echo = TRUE}

#USER INPUT NEEDED
Tcell_genes <- list("Cd3e","Cd8a", "Cd4")
Bcell_genes <- c("Cd19","Ms4a1","H2-Ab1")
Myeloid_genes <- c("Spi1", "H2-Ab1", "Cd24a", "Cd68", "Itgal", "Itgam")
NKcell_genes <- c("Ncr1","Il12rb2", "Itga1")
FetalCD8_genes <- c("Cd163l1","Igf1r")
RBC_genes <- c("Hba-a1", "Hbb-bs")

grouping_list <- list(Tcell_genes, Bcell_genes, Myeloid_genes, NKcell_genes, FetalCD8_genes, RBC_genes)
cluster_colors <- c("#F8766D", "#E68613", "#ABA300", "#0CB702", "#00BE67", "#00C19A", "#00A9FF", "#8494FF", "#ED68ED", "#FF61CC")

plot_list <- list()
i <- 1
for (geneset in grouping_list) {
  plot <- Stacked_VlnPlot(seurat_object = filtered_data_object,
                          features = geneset,
                          colors_use = cluster_colors)
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}


rm(plot, plot_list, i, geneset, Tcell_genes, Bcell_genes, Myeloid_genes, NKcell_genes, FetalCD8_genes, RBC_genes, grouping_list, cluster_colors)
gc()

``` 


## Identify doublets

```{r include = TRUE, echo = TRUE, eval = TRUE}
#USER INPUT REQUIRED
dataset <- filtered_data_object
groups <- "genotype"

reduction <- "initial_umap"
doublet_ID <- "scDblFinder.class"
scDbl_metadata <- c("scDblFinder.class", "scDblFinder.score", "scDblFinder.weighted", "scDblFinder.cxds_score", "scDblFinder.sample")

scDblObj <- scDblFinder(as.SingleCellExperiment(dataset),
                        samples = groups)

dataset <- AddMetaData(dataset,
                       metadata = as.data.frame(scDblObj@colData[,scDbl_metadata]))

table(dataset@meta.data$scDblFinder.class,
      dataset@meta.data$scDblFinder.sample)

#I have some doublets
DimPlot(object = dataset,
        reduction = reduction,
        group.by = doublet_ID,
        split.by = groups,
        order = TRUE)

Idents(dataset) <- doublet_ID

dataset <- subset(x = dataset,
                  idents = "singlet")




#doublet have been removed
table(dataset@meta.data$scDblFinder.class,
      dataset@meta.data$scDblFinder.sample)

DimPlot(object = dataset,
        reduction = reduction,
        group.by = doublet_ID,
        split.by = groups,
        order = TRUE)


#delete metadata for unused clustering results
metadata_to_delete <- list("scDblFinder.class",
                           "scDblFinder.weighted",
                           "scDblFinder.score",
                           "scDblFinder.sample",
                           "scDblFinder.cxds_score"
                           )
for (metadata in metadata_to_delete) {
  data_cat <- paste0("dataset$", metadata, " <- NULL")
  eval(rlang::parse_expr(data_cat))
}


#USER INPUT REQUIRED - update seruat object
filtered_data_object <- dataset



rm(dataset, groups, reduction, doublet_ID, scDbl_metadata, metadata, data_cat, scDblObj)
gc()

```

#     Create new (2nd) Seurat Object for the T cell clusters only (clusters 0-4).
      Will recluster and see if there' anything else I need to get rid of.

```{r include = TRUE, echo = TRUE}
clusters_to_keep <- c("0","1","2","3","4")

Tcell_data_object <- filtered_data_object %>% subset(seurat_clusters %in% clusters_to_keep)

table(Tcell_data_object@meta.data$RNA_snn_res.0.15, Tcell_data_object@meta.data$orig.ident)
table(Tcell_data_object@meta.data$Phase, Tcell_data_object@meta.data$genotype)

#Ok. Non-Tcell clusters have been removed. 

rm(clusters_to_keep)
gc()

```

##      Save/Load Tcell_data_object
        initial save
        PCA, tsne, UMAP, and reclustering have not been done
```{r include = TRUE, echo = TRUE}
seurat_directory <- "~/Sandbox/opa1-scRNAseq-local/seurat_objects/"
Tcell_object <- "Tcell_data_object_initial.RDS"


##### Save point #####
#saveRDS(object = Tcell_data_object, paste0(seurat_directory, Tcell_object))

##### Load if need be #####
Tcell_data_object <- readRDS(paste0(seurat_directory, Tcell_object))

##### cleanup #####
# no longer need filtered data object

rm(Tcell_object, filtered_data_object)
gc()
```


#       Tcell_data_object:
        ReRun t-SNE, UMAP, and clustering for Tcell only data

##     PCs - still 20
```{r include = TRUE, echo = TRUE}

##### Variables for running PCA and Finding Neighbors #####
assay <- "RNA"
seed <- 18
number_of_pcs <- 50

dimensions <- 50
reduction <- "pca"

Tcell_data_object <- RunPCA(object = Tcell_data_object,
                               assay = assay,
                               seed.use = seed,
                               npcs = number_of_pcs,
                               weight.by.var = TRUE)

ElbowPlot(object = Tcell_data_object,
          ndims = dimensions(),
          reduction = reduction)

##### Still using pcs = 20 #####
pcs <- 20

Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = reduction,
                                      dims = 1:pcs,
                                      assay = assay)

##### clean up #####
rm(assay, seed, number_of_pcs, reduction, dimensions())
gc()


```

##     t-SNE 

```{r include = TRUE, echo = TRUE}

##### Variables for tsne #####

reduction <- "pca"
assay <- "RNA"
seed <- 18
output_reduction_name <- "Tcell_tsne"

Tcell_data_object <- RunTSNE(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = reduction,
                                assay = assay,
                                seed.use = seed,
                                reduction.name = output_reduction_name)

#generating tsne plots
reduction <- "Tcell_tsne"
groupings <- list("orig.ident", "Phase")
dimensions <- 1:2 #standard

plot_list <- list()
i <- 1
for (group in groupings) {
  plot <- DimPlot(object = Tcell_data_object,
                  dims = dimensions,
                  reduction = reduction,
                  group.by = group)
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

##### clean up #####

rm(reduction, assay, seed, output_reduction_name, groupings, dimensions, plot_list, i, group, plot)
gc()



```

##     Run UMAP

        UMAP plots:
        1,2)    group by genotype and cell cycle phase
        3)      group by cell cycle phase, split by genotype
        
```{r include = TRUE, echo = TRUE}

##### variables for running UMAP #####
pcs <- 20
reduction <- "pca"
number_of_neighbors <- 30
seed <- 18
umap_name <- "Tcell_umap"


Tcell_data_object <- RunUMAP(object = Tcell_data_object,
                                dims = 1:pcs,
                                reduction = reduction,
                                assay = assay,
                                n.neighbors = number_of_neighbors,
                                seed.use = seed,
                                reduction.name = umap_name)
#generating UMAP plots
reduction <- "Tcell_umap"
grouping <- list("orig.ident", "Phase", "Phase")
splitting <- list(NULL, NULL, "orig.ident")
dimensions <- 1:2 #standard

plot_list <- list()
i <- 1
for (umap_index in 1:3) {
  plot <- DimPlot(object = Tcell_data_object,
                  dims = dimensions,
                  reduction = reduction,
                  group.by = grouping[[umap_index]],
                  split.by = splitting[[umap_index]])
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

##### cleanup #####

rm(reduction, number_of_neighbors, seed, umap_name, grouping, splitting, dimensions, umap_index, plot_list, plot, i)
gc()

```


##      Re-Clustering T cell object

###    Clustering Tcell_data_object
        resolutions tested: 0.05, 0.075, 0.1, 0.15, 0.2, 0.3
        
        0.075 used moving forward. Gives us 4 clusters to work with again.
```{r include = TRUE, echo = TRUE}

##### FindNeighbors and FindClusters variables: #####
reduction <- "pca"
assay <- "RNA"

resolutions_to_test <-c(0.05, 0.075, 0.1, 0.15, 0.2, 0.3)
seed <- 18
algo.num <- 1 #original Louvain algorithm

###### Reduction needed for plotting #####
reduction <- "Tcell_umap"

#####################
#####Clustering#####
#####################

Tcell_data_object <- FindNeighbors(object = Tcell_data_object,
                                      reduction = reduction,
                                      dims = 1:pcs,
                                      assay = assay)


Tcell_data_object <- FindClusters(object = Tcell_data_object,
                                     resolution = resolutions_to_test,
                                     algorithm = algo.num,
                                     random.seed = seed)



#Plotting clustering results
plot_list <- list()
i <-1 
for (res in resolutions_to_test) {
  plot <-   DimPlot(object = Tcell_data_object,
              reduction = reduction,
              label = FALSE,
              label.size = 6,
              group.by = paste0("RNA_snn_res.", res),
              split.by = "orig.ident") +
              ggtitle(paste0("Res = ", res))
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

#set active ident to correct resolution
Idents(object = Tcell_data_object) <- "RNA_snn_res.0.075"


#cleanup variables
rm(resolutions_to_test, seed, algo.num, assay, reduction, plot_list, plot, i, res, metadata_to_delete)
gc()

```

###    Visual check of new clustering
        Looks good
```{r include = TRUE, echo = TRUE}

##### VARIABLES ######

dimensions <- 1:2 #standard
reduction <- "Tcell_umap"
coloring <- list(c("Sky Blue", "Black"), NULL, NULL)

grouping <- list("orig.ident", "RNA_snn_res.0.075", "Phase")
splitting <- list(NULL, NULL, "orig.ident")


plot_list <- list()
i <- 1
for (umap_index in 1:3) {
  plot <- DimPlot(object = Tcell_data_object,
                  dims = dimensions,
                  cols = coloring[[umap_index]],
                  reduction = reduction,
                  group.by = grouping[[umap_index]],
                  split.by = splitting[[umap_index]])
  plot_list[[i]] <- plot
  i <- i + 1
}
for (i in 1:length(plot_list)) {
  print(plot_list[[i]])
}

rm(dimensions, reduction, coloring, grouping, splitting, plot_list, plot, i, umap_index)
gc()


```





DO I NEED THIS ANYMORE????


###   Set active ident and seurat_clusters to 0.075 

      Clean up Tcell_data_object metadata:
      remove resolutions 0.05, 0.1, 0.15, 0.2, 0.3
      remove singlets/doublets metadata
```{r include = TRUE, echo = TRUE}

Idents(object = Tcell_data_object) <- "RNA_snn_res.0.075"
Tcell_data_object$seurat_clusters <- Tcell_data_object@active.ident


#delete metadata for unused clustering results
metadata_to_delete <- list("RNA_snn_res.0.05", 
                           "RNA_snn_res.0.1",
                           "RNA_snn_res.0.15",
                           "RNA_snn_res.0.2",
                           "RNA_snn_res.0.3",
                           "scDblFinder.class",
                           "scDblFinder.weighted",
                           "scDblFinder.score",
                           "scDblFinder.sample",
                           "scDblFinder.cxds_score"
                           )
for (metadata in metadata_to_delete) {
  data_cat <- paste0("Tcell_data_object$", metadata, " <- NULL")
  eval(rlang::parse_expr(data_cat))
}

#set active ident to correct resolution
Idents(object = Tcell_data_object) <- "RNA_snn_res.0.075"

rm(scDblObj, metadata_to_delete, metadata, data_cat)
gc()

```










#     T Cell cluster wrangling
          Resolution = 0.0075 (This has also been 0.1 before. Looking for 4 total clusters: 
          1 naive and 3 activated clusters. 2 clusters are G1, 2 clusters are S/G2M)
          
##   Identify Naive T cell cluster based on Lef1 and Tcf7 expression.

```{r include = TRUE, echo = TRUE}
reduction <- "Tcell_umap"
genes <- c("Lef1", "Tcf7")
groups <- "genotype"


FeaturePlot(object = Tcell_data_object,
            reduction = reduction,
            features = "Lef1",
            split.by = groups,
            order = FALSE) + theme(legend.position = c(0.8,0.9))

FeaturePlot(object = Tcell_data_object,
            reduction = reduction,
            features = "Tcf7",
            split.by = groups,
            order = FALSE) + theme(legend.position = c(0.8,0.9))

```

##    Label cells as Naive and activated
      
      New metadata = activation_status

```{r include = TRUE, echo = TRUE}
#cluster 0    = naive
#cluster 1-3  = activated

Tcell_data_object$activation_status <- ifelse(test = Tcell_data_object$seurat_clusters == 0,
                                              yes = "naive",
                                              no = "activated")

#check
table(Tcell_data_object@active.ident, Tcell_data_object@meta.data$activation_status)

```


##    Removing single WT cells in the opa1_unique cluster
      Just to clean things up
      
```{r include = TRUE, echo = TRUE}
#single WT cell in the unique Opa1 cluster, removing for ease of any downstream analyses
table(Tcell_data_object@meta.data$seurat_clusters, Tcell_data_object@meta.data$orig.ident)


#found the wt cell in this clusters: "wt_CCCGGAAAGCTAGAAT"
head(WhichCells(Tcell_data_object, ident = "3"), 10)
toRemove <- "wt_CCCGGAAAGCTAGAAT"

#wt cell has been removed
Tcell_data_object <- Tcell_data_object[, !colnames(Tcell_data_object) %in% toRemove]
table(Tcell_data_object@meta.data$seurat_clusters, Tcell_data_object@meta.data$orig.ident)

rm(toRemove)
gc()

```

#   Save/Load Tcell_data_object for analysis
    
```{r include=TRUE, echo=TRUE}
seurat_directory <- "~/Sandbox/opa1-scRNAseq-local/seurat_objects/"
Tcell_object <- "Tcell_data_object_forAnalysis.RDS"

#saveRDS(object = Tcell_data_object, paste0(seurat_directory, Tcell_object))

##### load if need be #####
Tcell_data_object <- readRDS(paste0(seurat_directory, Tcell_object))

rm(Tcell_object, seurat_directory)
gc()
```




#       Figures for the paper!
        6A - 6H
        
```{r include = TRUE, echo = TRUE}

#Fig 6a
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "activation_status", cols = c("dark red","gray"))

#Fig 6b
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "genotype", cols = c("skyblue","black"))

#Fig 6c
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "seurat_clusters", split.by = "genotype", cols = c("black","lightgreen","tan","royalblue1"))

#Fig 6d
ggplot(Tcell_data_object@meta.data, aes(x = seurat_clusters, fill = genotype)) + scale_fill_manual(values = c("skyblue","black"))+ geom_bar(position = "fill") + ylab("Proportion of Cluster")

#Fig 6e
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "Phase", split.by = "genotype", cols = c("black","red","yellow"))

#Fig 6f
ggplot(Tcell_data_object@meta.data, aes(x = RNA_snn_res.0.075, fill = Phase)) + scale_fill_manual(values = c("black","red","yellow"))+ geom_bar() + xlab("Cluster")

```


#         Load in Pathways for GSEA (Supp 5B and 6K,L)  
          MSigDB pathways
```{r moduel score}
#OUTPUT: gmt_hallmark_list

MSigDB_directory <- "~/Sandbox/reference_data/MSigDB/"

Mm.h <- read.gmt(paste0(MSigDB_directory, "mh.all.v2023.2.Mm.symbols.gmt"))

#turn gmt file into list of pathways with genes associated with them
#Thank you T.Brunetti!
gmt <- Mm.h
transformed_gmt = gmt %>% group_by(term) %>% summarise(gene_list = str_c(sort(gene), collapse = ","), .groups = 'drop')
transformed_gmt = as.data.frame(transformed_gmt)
gmt_hallmark_list = list()
for (i in 1:nrow(transformed_gmt)){
  gmt_hallmark_list[[as.character(transformed_gmt[i, "term"])]] = unlist(stringr::str_split(transformed_gmt[i,'gene_list'], pattern = ','))
}


rm(gmt, transformed_gmt, i)
gc()
```

#         Supplemental Figure 5A
```{r moduel score}

#Fig S5A
supp5a_list <- c("Tcf7","Lef1","Bach2","Il7r","Ccr7","Mki67","Nr4a1","Gzmb","Gzmk","Ifng","Itgb1","Itgax","Il12rb1","Il12rb2","Prf1","Klrc1")

DotPlot(object = Tcell_data_object,
        features = supp5a_list) + 
  scale_colour_gradientn(colors = c("gray95","#FFFF99","#00CCCC","navy")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  ylab("Cluster") + 
  xlab("gene")

rm(supp5a_list)
```

#         Supplemental Figure 5B
          GSEA of hallmark pathways on clusters 1 and 3

```{r moduel score}

allMarkers <- FindAllMarkers(object = Tcell_data_object,
                             assay = "RNA",
                             logfc.threshold = 0.25,
                             test.use = "wilcox",
                             only.pos = FALSE,
                             verbose = TRUE,
                             layer = 'scale.data',
                             min.pct = 0.25)

#GSEA for cluster 1
cluster1_data <- allMarkers[allMarkers$cluster == "1",] 

#rank by log2FC
cluster1_ranks <- data.frame(gene = cluster1_data$gene, log2FC = cluster1_data$avg_log2FC)
#cluster1_ranks <- cluster1_ranks[order(cluster1_ranks$log2FC, decreasing = TRUE), ]
ranks_1 <- cluster1_ranks$log2FC
names(ranks_1) <- cluster1_ranks$gene

cluster1_fgsea_results <- fgsea(pathways = gmt_hallmark_list, stats = ranks_1, minSize = 15, maxSize = 500)


#Cluster 3
cluster3_data <- allMarkers[allMarkers$cluster == "3",] 
cluster3_ranks <- data.frame(gene = cluster3_data$gene, log2FC = cluster3_data$avg_log2FC)
ranks_3 <- cluster3_ranks$log2FC
names(ranks_3) <- cluster3_ranks$gene

cluster3_fgsea_results <- fgsea(pathways = gmt_hallmark_list, stats = ranks_3, minSize = 15, maxSize = 500)

#extract pathway and NES from GSEA results
df_list <- list()
cluster1_temp <- cluster1_fgsea_results[, c("pathway","NES"), drop = FALSE]
cluster3_temp <- cluster3_fgsea_results[, c("pathway","NES"), drop = FALSE]
df_list[[1]] <- cluster1_temp
df_list[[2]] <- cluster3_temp

#organize df that will be used for heatmap
combined_df <- Reduce(function(x, y) merge(x, y, by = "pathway", all = TRUE), df_list)
colnames(combined_df) <- c("pathway","cluster1", "cluster3")
combined_df <- as.data.frame(combined_df)
combined_df[is.na(combined_df)] <- 0
rownames(combined_df) <- combined_df$pathway

#remome HALLMARK_ from pathway names
pathway_names_altered <- list()
for (name in rownames(combined_df)) {
  name <- str_replace(name, "HALLMARK_", "")
  pathway_names_altered[[name]] <- name
}
rownames(combined_df) <- pathway_names_altered
combined_df$pathway <- NULL
combined_matrix_S5B <- as.matrix(combined_df)

pheatmap(combined_matrix_S5B,
         cluster_cols = FALSE,
         cluster_rows = FALSE,
         scale = "column",
         cellwidth = 10,
         cellheight = 6,
         fontsize_row = 6,
         fontsize_col = 6,
         main = "hi",
         color = colorRampPalette(c("white","blue4"))(20))

rm(cluster1_data, cluster1_fgsea_results, cluster1_ranks, cluster1_temp,cluster3_data, cluster3_fgsea_results, cluster3_ranks, cluster3_temp)
rm(combined_df, df_list, pathway_names_altered)
rm(name, ranks_1, ranks_3)

```

#         Supp Figure 5C
```{r moduel score}
#Get Myc targets and combine
Mm.h_entrez <- readRDS(file= paste0(MSigDB_directory, "Mm.h.all.v7.1.entrez.rds"))

Hallmark_Myc_targets_v1 <- mapIds(org.Mm.eg.db, Mm.h_entrez$HALLMARK_MYC_TARGETS_V1, 'SYMBOL', 'ENTREZID')
Hallmark_Myc_targets_v2 <- mapIds(org.Mm.eg.db, Mm.h_entrez$HALLMARK_MYC_TARGETS_V2, 'SYMBOL', 'ENTREZID')
myc_combined <- c(Hallmark_Myc_targets_v1, Hallmark_Myc_targets_v2)
  
Tcell_data_object <- AddModuleScore(Tcell_data_object, features = list(myc_combined), name = 'myc_combined')

Tcell_data_object@meta.data$myc_combined <- Tcell_data_object@meta.data$myc_combined1
Tcell_data_object@meta.data$myc_combined1 <- NULL




#plotting data
scored_list <- "myc_combined"
grouping <- "seurat_clusters"
colors <- c("black","#66FF99","tan","#0066CC")


VlnPlot(Tcell_data_object,
            features = "myc_combined",
            group.by = grouping,
            pt.size = 0,
            y.max = 0.85,
            cols = colors
            ) +
              labs(x = "cluster", y = "Module Score", title = "") +
              geom_hline(yintercept = c(0.2, 0.4, 0.6, 0.8), linetype = "dashed", color = "gray50")

rm(scored_list, grouping, colors)
rm(Hallmark_Myc_targets_v1, Hallmark_Myc_targets_v2, myc_combined)


```

##           Identify top defining genes per cluster
```{r include = TRUE, echo = TRUE}

top15perCluster <- allMarkers %>% group_by(cluster) %>% top_n(15, avg_log2FC)
```

###    DotPlots of top defining genes
```{r include = TRUE, echo = TRUE}

DotPlot(object = Tcell_data_object, features = unique(top15perCluster$gene)) +
         theme(axis.text.x = element_text(angle = 45, hjust = 1))


```
###    Heatmaps
```{r include = TRUE, echo = TRUE}

#this doesn't look like scott's but I think he also removed some clusters? idk...

DoHeatmap(Tcell_data_object, features = top15perCluster$gene, group.by = "seurat_clusters") + scale_fill_gradient2(high = "yellow1", mid ="#009966", low = "navy")

```




#   Generate files for cNMF analysis
    
```{r include=TRUE, echo=TRUE}

filtered_dir = '/Users/ben/Sandbox/opa1-scRNAseq-local/cnmf/'

counts <- Tcell_data_object@assays$RNA$counts
barcodes <- colnames(counts)
gene_names <- rownames(counts)



# Output counts matrix
writeMM(counts, paste0(filtered_dir, 'matrix.mtx'))

# Output cell barcodes
write.table(as.data.frame(barcodes), paste0(filtered_dir, 'barcodes.tsv'),
           col.names = FALSE, row.names = FALSE, sep = "\t")

# Output feature names
features <- data.frame("gene_id" = gene_names,"gene_name" = gene_names,type = "Gene Expression")
write.table(as.data.frame(features), sep = "\t", paste0(filtered_dir, 'genes.tsv'),
           col.names = FALSE, row.names = FALSE)

```

##    cNMF
```{r include = TRUE, echo = TRUE}

system(command = "cnmf prepare --output-dir ~/Sandbox/opa1-scRNAseq-local/cnmf/output_0226/ --name opa1_cnmf -c ~/Sandbox/opa1-scRNAseq-local/cnmf/matrix.mtx -k 4 5 6 --max-nmf-iter 2000 --n-iter 100 --numgenes 2000")

system(command = "cnmf factorize --output-dir ~/Sandbox/opa1-scRNAseq-local/cnmf/output_0226/ --name opa1_cnmf --worker-index 0 --total-workers 1")

system(command = "cnmf combine --output-dir ~/Sandbox/opa1-scRNAseq-local/cnmf/output_0226/ --name opa1_cnmf")


system(command = "cnmf k_selection_plot --output-dir ~/Sandbox/opa1-scRNAseq-local/cnmf/output_0226/ --name opa1_cnmf")

system(command = "cnmf consensus --output-dir ~/Sandbox/opa1-scRNAseq-local/cnmf/output_0226/ --name opa1_cnmf --components 5 --local-density-threshold 0.01 --show-clustering")

```

##    Load in cNMF outputs 
      Need local path to cNMF output files
```{r include = TRUE, echo = TRUE}
#directory with cNMF output files
cnmf_output_directory <- "~/Sandbox/opa1-scRNAseq-local/cnmf/output_0226/opa1_cnmf/"


usage_file <- read.table(paste0(cnmf_output_directory, "opa1_cnmf.usages.k_5.dt_0_01.consensus.txt"), sep = '\t', row.names = 1, header = TRUE)

spectra_score <- read.table(paste0(cnmf_output_directory, "opa1_cnmf.gene_spectra_score.k_5.dt_0_01.txt"), sep = '\t', row.names = 1, header = TRUE)
  
spectra_tpm <- read.table(paste0(cnmf_output_directory, "opa1_cnmf.gene_spectra_tpm.k_5.dt_0_01.txt"), sep = '\t', row.names = 1, header = TRUE)

usage_norm <- as.data.frame(t(apply(usage_file, 1, function(x) x / sum(x))))

```

##   Add cNMF data into metadata of seurat obj and plot on UMAP
    
```{r include = TRUE, echo = TRUE}

#rename usage_norm columns to GEPs
colnames(usage_norm) <- c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")

cnmf_metadata <- merge(Tcell_data_object@meta.data, usage_norm, by = "row.names", all.x = TRUE)

rownames(cnmf_metadata) <- cnmf_metadata$Row.names

#Apply an individual GEP to each cell based on the highest value of GEPs 1-5
cnmf_metadata <- cnmf_metadata %>%
  mutate(max_category = ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 1, "GEP1", 
                             ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 2, "GEP2",
                                    ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 3, "GEP3",
                                           ifelse(apply(cnmf_metadata[c("GEP1", "GEP2", "GEP3", "GEP4", "GEP5")], 1, FUN = which.max) == 4, "GEP4","GEP5"))))) 
Tcell_data_object@meta.data <- cnmf_metadata

Tcell_data_object@meta.data$Row.names <- NULL

```

#    Figures 6G-J
```{r include = TRUE, echo = TRUE}


#Fig 6G
DimPlot(object = Tcell_data_object, dims = 1:2, reduction = "Tcell_umap", group.by = "max_category", split.by = "genotype", cols = c("#6699cc","#003366","darkorange3","darkgreen", "gold3"), pt.size = 0.8) + labs(title = "")

#Fig 6H
#paper has Opa1 on bottom but thats ok. This is the gist of the plot
ggplot(Tcell_data_object@meta.data, aes(x = max_category, fill = genotype)) + scale_fill_manual(values = c("skyblue2","black"))+ geom_bar(position = "fill") + ylab("Frequency (%)")

#Fig 6i - WT
ggplot(data = Tcell_data_object@meta.data[Tcell_data_object@meta.data$genotype == "wt",], aes(x = max_category, fill = Phase)) + scale_fill_manual(values = c("black","red","yellow"))+ geom_bar() + xlab("Cluster") + labs(title = "WT") + theme(plot.title = element_text(hjust = 0.5, size = 25))

#Fig 6j - opa1
ggplot(data = Tcell_data_object@meta.data[Tcell_data_object@meta.data$genotype == "opa1",], aes(x = max_category, fill = Phase)) + scale_fill_manual(values = c("black","red","yellow"))+ geom_bar() + xlab("Cluster") + labs(title = "Opa1") + theme(plot.title = element_text(hjust = 0.5, size = 25))


```

#       Pathway analysis of GEPs! - THANK YOU FOR THE CODE T. BRUNETTI!!
        https://github.com/tbrunetti/cNMF_fgsea_wrapper
```{r include = TRUE, echo = TRUE}

library(fgsea)
library(clusterProfiler)
library(stringr)
library(pheatmap)
source("~/Sandbox/cNMF_fgsea_wrapper/scripts/fgsea_cNMF_ranks_funcs.R")

```

##      USER INPUT NEEDED
```{r include = TRUE, echo = TRUE}
#location of fgsea_cNMF_ranks_funcs.R file
#can get from Tonya's github
source("~/Sandbox/cNMF_fgsea_wrapper/scripts/fgsea_cNMF_ranks_funcs.R")
seed = 42

#locations of gmt files for BOTH hallark and gobp
gmt_file_input_hallmark = "~/Sandbox/reference_data/MSigDB/mh.all.v2023.2.Mm.symbols.gmt" #gmt file for hallmark (6K) files
gmt_file_input_gobp = "~/Sandbox/reference_data/MSigDB/m5.go.bp.v2023.2.Mm.symbols.gmt" #gmt file for gobp (6L) files

#output location
output_prefix = "~/Sandbox/opa1-scRNAseq-local/ross_vs_ben_output/" # path and prefix of what to call saved file

#locations for spectra file
cnmf_spectra_scores_file = "~/Sandbox/opa1-scRNAseq-local/cnmf/output_0226/opa1_cnmf/opa1_cnmf.gene_spectra_score.k_5.dt_0_01.txt"

#gobp file containing pathways shown in Fig 6L
gobp_csv <- read.csv("~/Sandbox/opa1-scRNAseq-local/Fig6L_pathways/supp_table.csv")


#other
adjp_thresh = 0.05 # non-inclusive, anything below this value will be retained
nes_thresh = "both" # options are positive, negative, or both

```

##      (1) Calculate enrichment scores with fgsea and (2) filter results by padj and NES - 6K (hallmark pathways)
```{r include = TRUE, echo = TRUE}

##########################################################################################
################## Step 1 - calculate your enrichment scores using fgsea #################
### ONLY NEEDS TO BE DONE ONCE FOR A DATASET, as data is save as .Rdat for use later! ####
##########################################################################################
step1_enrichment_results_6K <- calculate_enrichment(gmt_file_input = gmt_file_input_hallmark, 
                                                 output_prefix = output_prefix, 
                                                 cnmf_spectra_scores_file = cnmf_spectra_scores_file, 
                                                 seed = seed)

##########################################################################################
###################### Step 2 - filter fGSEA results by padj and NES #####################
##########################################################################################
filtered_fgsea_results_6K <- filter_results(unfiltered_fgsea_results = step1_enrichment_results_6K@unfiltered, 
                                         adjp_thresh = adjp_thresh, 
                                         nes_thresh = nes_thresh)



```


###      Figure 6K
```{r include = TRUE, echo = TRUE}

#for 6K
df_list <- list()
for (i in (1:5)){
  hallmark_GEP <- filtered_fgsea_results_6K[[i]]
  hallmark_GEP <- as.data.frame(hallmark_GEP)
  rownames(hallmark_GEP) <- hallmark_GEP$pathway
  hallmark_GEP <- hallmark_GEP[, c("pathway","NES"), drop = FALSE]
  df_list[[i]] <- hallmark_GEP
}

hallmark_df <- Reduce(function(x, y) merge(x, y, by = "pathway", all = TRUE), df_list)
colnames(hallmark_df) <- c("pathway", "GEP1", "GEP2", "GEP3", "GEP4", "GEP5")
hallmark_df[is.na(hallmark_df)] <- 0
rownames(hallmark_df) <- hallmark_df$pathway
hallmark_df$pathway <- NULL


#remome HALLMARK_ from pathway names
pathway_names_altered <- list()
for (name in rownames(hallmark_df)) {
  name <- str_replace(name, "HALLMARK_", "")
  pathway_names_altered[[name]] <- name
}
rownames(hallmark_df) <- pathway_names_altered



#remove pathways to be excluded in heatmap
#yes this is not a great way to order the pathways. I am just reproducing the plots from the figure here.
hallmark_df$temp <- rownames(hallmark_df)
heatmap_pathways <- c("MYC_TARGETS_V1", "MYC_TARGETS_V2", "OXIDATIVE_PHOSPHORYLATION", "MTORC1_SIGNALING", "UNFOLDED_PROTEIN_RESPONSE", "GLYCOLYSIS", "FATTY_ACID_METABOLISM", "DNA_REPAIR", "UV_RESPONSE_UP", "UV_RESPONSE_DN", "XENOBIOTIC_METABOLISM", "P53_PATHWAY", "HYPOXIA", "IL2_STAT5_SIGNALING", "KRAS_SIGNALING_DN", "HEME_METABOLISM", "INTERFERON_GAMMA_RESPONSE", "ALLOGRAFT_REJECTION", "KRAS_SIGNALING_UP", "IL6_JAK_STAT3_SIGNALING", "INFLAMMATORY_RESPONSE", "TNFA_SIGNALING_VIA_NFKB", "COMPLEMENT", "APICAL_JUNCTION", "PROTEIN_SECRETION", "APICAL_SURFACE", "E2F_TARGETS", "G2M_CHECKPOINT", "MITOTIC_SPINDLE")

hallmark_df <- hallmark_df %>% dplyr::filter(temp %in% heatmap_pathways)
hallmark_df$temp <- NULL

hallmark_df_ordered <- hallmark_df %>% arrange(match(rownames(hallmark_df), heatmap_pathways))

hallmark_df_ordered <- as.matrix(hallmark_df_ordered)

pheatmap(hallmark_df_ordered,
         cluster_cols = FALSE,
         cluster_rows = FALSE,
         scale = "row",
         cellwidth = 10,
         cellheight = 10,
         fontsize_row = 8,
         color = c("blue4","cornsilk4","yellow2")) 

rm(hallmark)

```

##      (1) Calculate enrichment scores with fgsea and (2) filter results by padj and NES - 6L (gobp pathways)
```{r include = TRUE, echo = TRUE}

##########################################################################################
################## Step 1 - calculate your enrichment scores using fgsea #################
### ONLY NEEDS TO BE DONE ONCE FOR A DATASET, as data is save as .Rdat for use later! ####
##########################################################################################
step1_enrichment_results_6L <- calculate_enrichment(gmt_file_input = gmt_file_input_gobp, 
                                                 output_prefix = output_prefix, 
                                                 cnmf_spectra_scores_file = cnmf_spectra_scores_file, 
                                                 seed = seed)

##########################################################################################
###################### Step 2 - filter fGSEA results by padj and NES #####################
##########################################################################################
filtered_fgsea_results_6L <- filter_results(unfiltered_fgsea_results = step1_enrichment_results_6L@unfiltered, 
                                         adjp_thresh = adjp_thresh, 
                                         nes_thresh = nes_thresh)



```

###      Figure 6L
```{r include = TRUE, echo = TRUE}
#for Figure 6L
#extract NES for pathways in each GEP from filtered_fgsea_results
df_list <- list()
for (i in (1:5)){
  GEP <- filtered_fgsea_results_6L[[i]]
  GEP <- as.data.frame(GEP)
  rownames(GEP) <- GEP$pathway
  GEP <- GEP[, c("pathway","NES"), drop = FALSE]
  df_list[[i]] <- GEP
}

#merge NES for each GEP it one dataframe
gobp_df

gobp_df <- Reduce(function(x, y) merge(x, y, by = "pathway", all = TRUE), df_list)
colnames(gobp_df) <- c("pathway", "GEP1", "GEP2", "GEP3", "GEP4", "GEP5")
gobp_df[is.na(gobp_df)] <- 0
rownames(gobp_df) <- gobp_df$pathway
gobp_df$pathway <- NULL

#check
head(gobp_df)


#remome GOBP_ from pathway names
pathway_names_altered <- list()
for (name in rownames(gobp_df)) {
  name <- str_replace(name, "GOBP_", "")
  pathway_names_altered[[name]] <- name
}
rownames(gobp_df) <- pathway_names_altered

#check
head(gobp_df)

pathways_of_interest_df <- gobp_csv[, c("category", "pathway")]


row_index <- rownames(pathways_of_interest_df)
index <- 0
gobp_heatmap_pathways <- list()
for (pathway in pathways_of_interest_df$pathway) {
  gobp_heatmap_pathways[[pathway]] <- pathway
  index = index + 1
}

head(names(gobp_heatmap_pathways))

gobp_df$pathway <- rownames(gobp_df)
gobp_df_heatmap <- gobp_df %>% dplyr::filter(pathway %in% names(gobp_heatmap_pathways))

#add category for pathway that will be used to group in figure
gobp_df_heatmap$category <- pathways_of_interest_df$category[match(gobp_df_heatmap$pathway, pathways_of_interest_df$pathway)]

#remove pathways with NA values
gobp_df_heatmap <- gobp_df_heatmap[complete.cases(gobp_df_heatmap), ]


gobp_df_heatmap <- gobp_df_heatmap[order(gobp_df_heatmap$category, decreasing = FALSE), ]

gobp_df_heatmap$category <- NULL
gobp_df_heatmap$pathway <- NULL


gobp_df_heatmap <- as.matrix(gobp_df_heatmap)

pheatmap(gobp_df_heatmap,
         cluster_cols = FALSE,
         cluster_rows = FALSE,
         scale = "row", 
         cellwidth = 7.5,
         cellheight = 4,
         fontsize_row = 4,
         fontsize_col = 6,
         color = colorRampPalette(c("blue4","cornsilk4","yellow1"))(25))

rm(gobp_csv, gobp_df, gobp_df_heatmap, gobp_heatmap_pathways, pathways_of_interest_df)




```




